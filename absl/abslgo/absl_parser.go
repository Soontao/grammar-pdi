// Code generated from ./ABSLParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package abslgo // ABSLParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 129, 995,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 3, 2,
	5, 2, 152, 10, 2, 3, 2, 5, 2, 155, 10, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 4,
	3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4,
	3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 181, 10, 4, 3, 5, 3, 5,
	5, 5, 185, 10, 5, 3, 5, 3, 5, 3, 6, 6, 6, 190, 10, 6, 13, 6, 14, 6, 191,
	3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 199, 10, 7, 3, 7, 5, 7, 202, 10, 7,
	5, 7, 204, 10, 7, 3, 8, 5, 8, 207, 10, 8, 3, 8, 3, 8, 5, 8, 211, 10, 8,
	3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 218, 10, 8, 3, 9, 3, 9, 3, 9, 3, 9,
	7, 9, 224, 10, 9, 12, 9, 14, 9, 227, 11, 9, 3, 9, 3, 9, 5, 9, 231, 10,
	9, 5, 9, 233, 10, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3,
	11, 5, 11, 243, 10, 11, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 5, 13,
	251, 10, 13, 3, 14, 3, 14, 3, 14, 5, 14, 256, 10, 14, 3, 14, 3, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 265, 10, 14, 3, 15, 3, 15, 3, 15,
	3, 15, 3, 15, 3, 15, 5, 15, 273, 10, 15, 3, 15, 3, 15, 5, 15, 277, 10,
	15, 3, 16, 3, 16, 3, 16, 5, 16, 282, 10, 16, 3, 17, 3, 17, 3, 17, 3, 17,
	3, 18, 3, 18, 3, 18, 7, 18, 291, 10, 18, 12, 18, 14, 18, 294, 11, 18, 3,
	19, 3, 19, 3, 19, 5, 19, 299, 10, 19, 3, 19, 3, 19, 5, 19, 303, 10, 19,
	3, 20, 5, 20, 306, 10, 20, 3, 20, 5, 20, 309, 10, 20, 3, 20, 3, 20, 3,
	21, 3, 21, 3, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 5, 23, 325, 10, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3,
	24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24,
	3, 24, 5, 24, 345, 10, 24, 3, 24, 3, 24, 5, 24, 349, 10, 24, 3, 24, 3,
	24, 5, 24, 353, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24,
	361, 10, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 5, 24, 370,
	10, 24, 3, 24, 3, 24, 3, 24, 5, 24, 375, 10, 24, 3, 24, 3, 24, 3, 24, 3,
	24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24,
	5, 24, 391, 10, 24, 3, 25, 3, 25, 3, 26, 3, 26, 5, 26, 397, 10, 26, 3,
	26, 3, 26, 3, 27, 3, 27, 5, 27, 403, 10, 27, 3, 27, 3, 27, 3, 28, 3, 28,
	5, 28, 409, 10, 28, 3, 28, 3, 28, 3, 29, 3, 29, 5, 29, 415, 10, 29, 3,
	29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31,
	3, 31, 3, 31, 3, 31, 3, 32, 3, 32, 5, 32, 433, 10, 32, 3, 32, 3, 32, 5,
	32, 437, 10, 32, 5, 32, 439, 10, 32, 3, 32, 3, 32, 3, 33, 6, 33, 444, 10,
	33, 13, 33, 14, 33, 445, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 452, 10, 34,
	3, 34, 3, 34, 5, 34, 456, 10, 34, 3, 34, 3, 34, 5, 34, 460, 10, 34, 3,
	34, 5, 34, 463, 10, 34, 5, 34, 465, 10, 34, 3, 35, 3, 35, 5, 35, 469, 10,
	35, 3, 35, 5, 35, 472, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 37, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 486, 10, 37, 3, 38, 3,
	38, 3, 38, 3, 38, 5, 38, 492, 10, 38, 3, 38, 5, 38, 495, 10, 38, 3, 39,
	3, 39, 3, 39, 5, 39, 500, 10, 39, 3, 39, 5, 39, 503, 10, 39, 3, 39, 3,
	39, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 42, 5, 42, 514, 10, 42,
	3, 42, 3, 42, 5, 42, 518, 10, 42, 3, 42, 3, 42, 3, 42, 5, 42, 523, 10,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 43, 3, 43, 3, 43, 3, 43, 3, 44,
	3, 44, 5, 44, 536, 10, 44, 3, 44, 3, 44, 7, 44, 540, 10, 44, 12, 44, 14,
	44, 543, 11, 44, 3, 44, 3, 44, 3, 45, 7, 45, 548, 10, 45, 12, 45, 14, 45,
	551, 11, 45, 3, 45, 3, 45, 3, 45, 5, 45, 556, 10, 45, 3, 45, 3, 45, 3,
	45, 3, 45, 5, 45, 562, 10, 45, 3, 46, 5, 46, 565, 10, 46, 3, 46, 5, 46,
	568, 10, 46, 3, 46, 3, 46, 3, 46, 5, 46, 573, 10, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 5, 46, 581, 10, 46, 3, 46, 5, 46, 584, 10, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 594, 10,
	46, 3, 46, 5, 46, 597, 10, 46, 3, 46, 3, 46, 3, 46, 5, 46, 602, 10, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 609, 10, 46, 3, 47, 3, 47, 3,
	47, 7, 47, 614, 10, 47, 12, 47, 14, 47, 617, 11, 47, 3, 47, 3, 47, 5, 47,
	621, 10, 47, 3, 47, 5, 47, 624, 10, 47, 3, 48, 3, 48, 3, 48, 5, 48, 629,
	10, 48, 3, 49, 3, 49, 3, 49, 3, 50, 5, 50, 635, 10, 50, 3, 51, 6, 51, 638,
	10, 51, 13, 51, 14, 51, 639, 3, 52, 3, 52, 3, 52, 3, 52, 3, 53, 7, 53,
	647, 10, 53, 12, 53, 14, 53, 650, 11, 53, 3, 53, 5, 53, 653, 10, 53, 3,
	53, 6, 53, 656, 10, 53, 13, 53, 14, 53, 657, 3, 53, 7, 53, 661, 10, 53,
	12, 53, 14, 53, 664, 11, 53, 3, 53, 7, 53, 667, 10, 53, 12, 53, 14, 53,
	670, 11, 53, 3, 54, 5, 54, 673, 10, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3,
	55, 3, 55, 7, 55, 681, 10, 55, 12, 55, 14, 55, 684, 11, 55, 5, 55, 686,
	10, 55, 3, 55, 5, 55, 689, 10, 55, 3, 55, 3, 55, 3, 56, 3, 56, 3, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 704, 10, 56,
	3, 56, 5, 56, 707, 10, 56, 3, 56, 3, 56, 3, 56, 5, 56, 712, 10, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56,
	3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5,
	56, 735, 10, 56, 3, 56, 5, 56, 738, 10, 56, 3, 57, 3, 57, 3, 57, 3, 57,
	3, 57, 3, 57, 3, 57, 5, 57, 747, 10, 57, 3, 58, 3, 58, 3, 58, 3, 58, 7,
	58, 753, 10, 58, 12, 58, 14, 58, 756, 11, 58, 3, 58, 5, 58, 759, 10, 58,
	5, 58, 761, 10, 58, 3, 58, 3, 58, 3, 59, 5, 59, 766, 10, 59, 3, 59, 3,
	59, 5, 59, 770, 10, 59, 3, 60, 3, 60, 3, 60, 7, 60, 775, 10, 60, 12, 60,
	14, 60, 778, 11, 60, 3, 61, 3, 61, 3, 61, 3, 61, 5, 61, 784, 10, 61, 3,
	61, 3, 61, 3, 61, 3, 61, 5, 61, 790, 10, 61, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 3, 61, 3, 61, 5, 61, 831, 10, 61, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61,
	3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 5, 61, 895, 10, 61, 3, 61, 3, 61,
	5, 61, 899, 10, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 7, 61, 910, 10, 61, 12, 61, 14, 61, 913, 11, 61, 3, 62, 3, 62,
	3, 62, 5, 62, 918, 10, 62, 3, 63, 3, 63, 5, 63, 922, 10, 63, 3, 63, 3,
	63, 5, 63, 926, 10, 63, 3, 63, 3, 63, 5, 63, 930, 10, 63, 3, 63, 3, 63,
	3, 63, 3, 63, 3, 63, 3, 63, 5, 63, 938, 10, 63, 3, 63, 3, 63, 3, 63, 3,
	63, 5, 63, 944, 10, 63, 3, 64, 3, 64, 3, 64, 5, 64, 949, 10, 64, 3, 64,
	5, 64, 952, 10, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 959, 10,
	65, 3, 66, 3, 66, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67,
	970, 10, 67, 3, 68, 3, 68, 3, 69, 3, 69, 3, 70, 3, 70, 5, 70, 978, 10,
	70, 3, 71, 3, 71, 3, 71, 5, 71, 983, 10, 71, 3, 72, 3, 72, 3, 73, 3, 73,
	3, 73, 3, 74, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 2, 3, 120, 76, 2, 4, 6,
	8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 146, 148, 2, 14, 5, 2, 81, 81, 108, 108, 114, 114, 5, 2, 111, 111,
	120, 120, 122, 122, 3, 2, 26, 28, 3, 2, 22, 23, 3, 2, 32, 34, 3, 2, 35,
	38, 3, 2, 39, 42, 3, 2, 48, 59, 3, 2, 63, 67, 3, 2, 68, 71, 6, 2, 72, 73,
	76, 87, 89, 97, 99, 121, 3, 3, 13, 13, 2, 1119, 2, 151, 3, 2, 2, 2, 4,
	158, 3, 2, 2, 2, 6, 180, 3, 2, 2, 2, 8, 182, 3, 2, 2, 2, 10, 189, 3, 2,
	2, 2, 12, 203, 3, 2, 2, 2, 14, 217, 3, 2, 2, 2, 16, 219, 3, 2, 2, 2, 18,
	236, 3, 2, 2, 2, 20, 239, 3, 2, 2, 2, 22, 244, 3, 2, 2, 2, 24, 247, 3,
	2, 2, 2, 26, 264, 3, 2, 2, 2, 28, 276, 3, 2, 2, 2, 30, 281, 3, 2, 2, 2,
	32, 283, 3, 2, 2, 2, 34, 287, 3, 2, 2, 2, 36, 295, 3, 2, 2, 2, 38, 305,
	3, 2, 2, 2, 40, 312, 3, 2, 2, 2, 42, 314, 3, 2, 2, 2, 44, 317, 3, 2, 2,
	2, 46, 390, 3, 2, 2, 2, 48, 392, 3, 2, 2, 2, 50, 394, 3, 2, 2, 2, 52, 400,
	3, 2, 2, 2, 54, 406, 3, 2, 2, 2, 56, 412, 3, 2, 2, 2, 58, 418, 3, 2, 2,
	2, 60, 424, 3, 2, 2, 2, 62, 430, 3, 2, 2, 2, 64, 443, 3, 2, 2, 2, 66, 464,
	3, 2, 2, 2, 68, 466, 3, 2, 2, 2, 70, 473, 3, 2, 2, 2, 72, 485, 3, 2, 2,
	2, 74, 487, 3, 2, 2, 2, 76, 496, 3, 2, 2, 2, 78, 506, 3, 2, 2, 2, 80, 509,
	3, 2, 2, 2, 82, 513, 3, 2, 2, 2, 84, 529, 3, 2, 2, 2, 86, 535, 3, 2, 2,
	2, 88, 561, 3, 2, 2, 2, 90, 608, 3, 2, 2, 2, 92, 623, 3, 2, 2, 2, 94, 625,
	3, 2, 2, 2, 96, 630, 3, 2, 2, 2, 98, 634, 3, 2, 2, 2, 100, 637, 3, 2, 2,
	2, 102, 641, 3, 2, 2, 2, 104, 648, 3, 2, 2, 2, 106, 672, 3, 2, 2, 2, 108,
	676, 3, 2, 2, 2, 110, 737, 3, 2, 2, 2, 112, 746, 3, 2, 2, 2, 114, 748,
	3, 2, 2, 2, 116, 765, 3, 2, 2, 2, 118, 771, 3, 2, 2, 2, 120, 830, 3, 2,
	2, 2, 122, 917, 3, 2, 2, 2, 124, 943, 3, 2, 2, 2, 126, 951, 3, 2, 2, 2,
	128, 958, 3, 2, 2, 2, 130, 960, 3, 2, 2, 2, 132, 969, 3, 2, 2, 2, 134,
	971, 3, 2, 2, 2, 136, 973, 3, 2, 2, 2, 138, 977, 3, 2, 2, 2, 140, 982,
	3, 2, 2, 2, 142, 984, 3, 2, 2, 2, 144, 986, 3, 2, 2, 2, 146, 989, 3, 2,
	2, 2, 148, 992, 3, 2, 2, 2, 150, 152, 7, 3, 2, 2, 151, 150, 3, 2, 2, 2,
	151, 152, 3, 2, 2, 2, 152, 154, 3, 2, 2, 2, 153, 155, 5, 100, 51, 2, 154,
	153, 3, 2, 2, 2, 154, 155, 3, 2, 2, 2, 155, 156, 3, 2, 2, 2, 156, 157,
	7, 2, 2, 3, 157, 3, 3, 2, 2, 2, 158, 159, 5, 6, 4, 2, 159, 5, 3, 2, 2,
	2, 160, 181, 5, 8, 5, 2, 161, 181, 5, 32, 17, 2, 162, 181, 5, 12, 7, 2,
	163, 181, 5, 26, 14, 2, 164, 181, 5, 40, 21, 2, 165, 181, 5, 84, 43, 2,
	166, 181, 5, 42, 22, 2, 167, 181, 5, 44, 23, 2, 168, 181, 5, 46, 24, 2,
	169, 181, 5, 50, 26, 2, 170, 181, 5, 52, 27, 2, 171, 181, 5, 54, 28, 2,
	172, 181, 5, 56, 29, 2, 173, 181, 5, 58, 30, 2, 174, 181, 5, 70, 36, 2,
	175, 181, 5, 60, 31, 2, 176, 181, 5, 72, 37, 2, 177, 181, 5, 74, 38, 2,
	178, 181, 5, 80, 41, 2, 179, 181, 5, 82, 42, 2, 180, 160, 3, 2, 2, 2, 180,
	161, 3, 2, 2, 2, 180, 162, 3, 2, 2, 2, 180, 163, 3, 2, 2, 2, 180, 164,
	3, 2, 2, 2, 180, 165, 3, 2, 2, 2, 180, 166, 3, 2, 2, 2, 180, 167, 3, 2,
	2, 2, 180, 168, 3, 2, 2, 2, 180, 169, 3, 2, 2, 2, 180, 170, 3, 2, 2, 2,
	180, 171, 3, 2, 2, 2, 180, 172, 3, 2, 2, 2, 180, 173, 3, 2, 2, 2, 180,
	174, 3, 2, 2, 2, 180, 175, 3, 2, 2, 2, 180, 176, 3, 2, 2, 2, 180, 177,
	3, 2, 2, 2, 180, 178, 3, 2, 2, 2, 180, 179, 3, 2, 2, 2, 181, 7, 3, 2, 2,
	2, 182, 184, 7, 11, 2, 2, 183, 185, 5, 10, 6, 2, 184, 183, 3, 2, 2, 2,
	184, 185, 3, 2, 2, 2, 185, 186, 3, 2, 2, 2, 186, 187, 7, 12, 2, 2, 187,
	9, 3, 2, 2, 2, 188, 190, 5, 6, 4, 2, 189, 188, 3, 2, 2, 2, 190, 191, 3,
	2, 2, 2, 191, 189, 3, 2, 2, 2, 191, 192, 3, 2, 2, 2, 192, 11, 3, 2, 2,
	2, 193, 194, 7, 110, 2, 2, 194, 204, 5, 14, 8, 2, 195, 196, 7, 110, 2,
	2, 196, 198, 5, 120, 61, 2, 197, 199, 7, 102, 2, 2, 198, 197, 3, 2, 2,
	2, 198, 199, 3, 2, 2, 2, 199, 201, 3, 2, 2, 2, 200, 202, 7, 122, 2, 2,
	201, 200, 3, 2, 2, 2, 201, 202, 3, 2, 2, 2, 202, 204, 3, 2, 2, 2, 203,
	193, 3, 2, 2, 2, 203, 195, 3, 2, 2, 2, 204, 13, 3, 2, 2, 2, 205, 207, 5,
	18, 10, 2, 206, 205, 3, 2, 2, 2, 206, 207, 3, 2, 2, 2, 207, 210, 3, 2,
	2, 2, 208, 211, 5, 20, 11, 2, 209, 211, 5, 16, 9, 2, 210, 208, 3, 2, 2,
	2, 210, 209, 3, 2, 2, 2, 211, 212, 3, 2, 2, 2, 212, 213, 5, 22, 12, 2,
	213, 214, 5, 148, 75, 2, 214, 218, 3, 2, 2, 2, 215, 216, 7, 123, 2, 2,
	216, 218, 5, 148, 75, 2, 217, 206, 3, 2, 2, 2, 217, 215, 3, 2, 2, 2, 218,
	15, 3, 2, 2, 2, 219, 225, 7, 11, 2, 2, 220, 221, 5, 24, 13, 2, 221, 222,
	7, 14, 2, 2, 222, 224, 3, 2, 2, 2, 223, 220, 3, 2, 2, 2, 224, 227, 3, 2,
	2, 2, 225, 223, 3, 2, 2, 2, 225, 226, 3, 2, 2, 2, 226, 232, 3, 2, 2, 2,
	227, 225, 3, 2, 2, 2, 228, 230, 5, 24, 13, 2, 229, 231, 7, 14, 2, 2, 230,
	229, 3, 2, 2, 2, 230, 231, 3, 2, 2, 2, 231, 233, 3, 2, 2, 2, 232, 228,
	3, 2, 2, 2, 232, 233, 3, 2, 2, 2, 233, 234, 3, 2, 2, 2, 234, 235, 7, 12,
	2, 2, 235, 17, 3, 2, 2, 2, 236, 237, 5, 24, 13, 2, 237, 238, 7, 14, 2,
	2, 238, 19, 3, 2, 2, 2, 239, 242, 7, 26, 2, 2, 240, 241, 7, 102, 2, 2,
	241, 243, 5, 138, 70, 2, 242, 240, 3, 2, 2, 2, 242, 243, 3, 2, 2, 2, 243,
	21, 3, 2, 2, 2, 244, 245, 7, 103, 2, 2, 245, 246, 7, 123, 2, 2, 246, 23,
	3, 2, 2, 2, 247, 250, 5, 138, 70, 2, 248, 249, 7, 102, 2, 2, 249, 251,
	5, 138, 70, 2, 250, 248, 3, 2, 2, 2, 250, 251, 3, 2, 2, 2, 251, 25, 3,
	2, 2, 2, 252, 255, 7, 109, 2, 2, 253, 256, 5, 28, 15, 2, 254, 256, 5, 30,
	16, 2, 255, 253, 3, 2, 2, 2, 255, 254, 3, 2, 2, 2, 256, 257, 3, 2, 2, 2,
	257, 258, 5, 148, 75, 2, 258, 265, 3, 2, 2, 2, 259, 260, 7, 109, 2, 2,
	260, 261, 7, 95, 2, 2, 261, 262, 5, 120, 61, 2, 262, 263, 5, 148, 75, 2,
	263, 265, 3, 2, 2, 2, 264, 252, 3, 2, 2, 2, 264, 259, 3, 2, 2, 2, 265,
	27, 3, 2, 2, 2, 266, 267, 5, 20, 11, 2, 267, 268, 5, 22, 12, 2, 268, 269,
	5, 148, 75, 2, 269, 277, 3, 2, 2, 2, 270, 272, 5, 16, 9, 2, 271, 273, 5,
	22, 12, 2, 272, 271, 3, 2, 2, 2, 272, 273, 3, 2, 2, 2, 273, 274, 3, 2,
	2, 2, 274, 275, 5, 148, 75, 2, 275, 277, 3, 2, 2, 2, 276, 266, 3, 2, 2,
	2, 276, 270, 3, 2, 2, 2, 277, 29, 3, 2, 2, 2, 278, 282, 5, 32, 17, 2, 279,
	282, 5, 84, 43, 2, 280, 282, 5, 82, 42, 2, 281, 278, 3, 2, 2, 2, 281, 279,
	3, 2, 2, 2, 281, 280, 3, 2, 2, 2, 282, 31, 3, 2, 2, 2, 283, 284, 5, 48,
	25, 2, 284, 285, 5, 34, 18, 2, 285, 286, 5, 148, 75, 2, 286, 33, 3, 2,
	2, 2, 287, 292, 5, 36, 19, 2, 288, 289, 7, 14, 2, 2, 289, 291, 5, 36, 19,
	2, 290, 288, 3, 2, 2, 2, 291, 294, 3, 2, 2, 2, 292, 290, 3, 2, 2, 2, 292,
	293, 3, 2, 2, 2, 293, 35, 3, 2, 2, 2, 294, 292, 3, 2, 2, 2, 295, 298, 5,
	122, 62, 2, 296, 297, 7, 17, 2, 2, 297, 299, 5, 38, 20, 2, 298, 296, 3,
	2, 2, 2, 298, 299, 3, 2, 2, 2, 299, 302, 3, 2, 2, 2, 300, 301, 7, 15, 2,
	2, 301, 303, 5, 120, 61, 2, 302, 300, 3, 2, 2, 2, 302, 303, 3, 2, 2, 2,
	303, 37, 3, 2, 2, 2, 304, 306, 7, 74, 2, 2, 305, 304, 3, 2, 2, 2, 305,
	306, 3, 2, 2, 2, 306, 308, 3, 2, 2, 2, 307, 309, 7, 75, 2, 2, 308, 307,
	3, 2, 2, 2, 308, 309, 3, 2, 2, 2, 309, 310, 3, 2, 2, 2, 310, 311, 5, 120,
	61, 2, 311, 39, 3, 2, 2, 2, 312, 313, 7, 13, 2, 2, 313, 41, 3, 2, 2, 2,
	314, 315, 5, 118, 60, 2, 315, 316, 5, 148, 75, 2, 316, 43, 3, 2, 2, 2,
	317, 318, 7, 96, 2, 2, 318, 319, 7, 9, 2, 2, 319, 320, 5, 118, 60, 2, 320,
	321, 7, 10, 2, 2, 321, 324, 5, 6, 4, 2, 322, 323, 7, 79, 2, 2, 323, 325,
	5, 6, 4, 2, 324, 322, 3, 2, 2, 2, 324, 325, 3, 2, 2, 2, 325, 45, 3, 2,
	2, 2, 326, 327, 7, 73, 2, 2, 327, 328, 5, 6, 4, 2, 328, 329, 7, 90, 2,
	2, 329, 330, 7, 9, 2, 2, 330, 331, 5, 118, 60, 2, 331, 332, 7, 10, 2, 2,
	332, 333, 5, 148, 75, 2, 333, 391, 3, 2, 2, 2, 334, 335, 7, 90, 2, 2, 335,
	336, 7, 9, 2, 2, 336, 337, 5, 118, 60, 2, 337, 338, 7, 10, 2, 2, 338, 339,
	5, 6, 4, 2, 339, 391, 3, 2, 2, 2, 340, 341, 7, 87, 2, 2, 341, 344, 7, 9,
	2, 2, 342, 345, 5, 118, 60, 2, 343, 345, 5, 32, 17, 2, 344, 342, 3, 2,
	2, 2, 344, 343, 3, 2, 2, 2, 344, 345, 3, 2, 2, 2, 345, 346, 3, 2, 2, 2,
	346, 348, 7, 13, 2, 2, 347, 349, 5, 118, 60, 2, 348, 347, 3, 2, 2, 2, 348,
	349, 3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 352, 7, 13, 2, 2, 351, 353,
	5, 118, 60, 2, 352, 351, 3, 2, 2, 2, 352, 353, 3, 2, 2, 2, 353, 354, 3,
	2, 2, 2, 354, 355, 7, 10, 2, 2, 355, 391, 5, 6, 4, 2, 356, 357, 7, 87,
	2, 2, 357, 360, 7, 9, 2, 2, 358, 361, 5, 120, 61, 2, 359, 361, 5, 32, 17,
	2, 360, 358, 3, 2, 2, 2, 360, 359, 3, 2, 2, 2, 361, 362, 3, 2, 2, 2, 362,
	363, 7, 100, 2, 2, 363, 364, 5, 118, 60, 2, 364, 365, 7, 10, 2, 2, 365,
	366, 5, 6, 4, 2, 366, 391, 3, 2, 2, 2, 367, 369, 7, 87, 2, 2, 368, 370,
	7, 112, 2, 2, 369, 368, 3, 2, 2, 2, 369, 370, 3, 2, 2, 2, 370, 371, 3,
	2, 2, 2, 371, 374, 7, 9, 2, 2, 372, 375, 5, 120, 61, 2, 373, 375, 5, 32,
	17, 2, 374, 372, 3, 2, 2, 2, 374, 373, 3, 2, 2, 2, 375, 376, 3, 2, 2, 2,
	376, 377, 7, 122, 2, 2, 377, 378, 5, 118, 60, 2, 378, 379, 7, 10, 2, 2,
	379, 380, 5, 6, 4, 2, 380, 391, 3, 2, 2, 2, 381, 382, 7, 88, 2, 2, 382,
	383, 7, 9, 2, 2, 383, 384, 7, 81, 2, 2, 384, 385, 7, 122, 2, 2, 385, 386,
	7, 100, 2, 2, 386, 387, 5, 120, 61, 2, 387, 388, 7, 10, 2, 2, 388, 389,
	5, 6, 4, 2, 389, 391, 3, 2, 2, 2, 390, 326, 3, 2, 2, 2, 390, 334, 3, 2,
	2, 2, 390, 340, 3, 2, 2, 2, 390, 356, 3, 2, 2, 2, 390, 367, 3, 2, 2, 2,
	390, 381, 3, 2, 2, 2, 391, 47, 3, 2, 2, 2, 392, 393, 9, 2, 2, 2, 393, 49,
	3, 2, 2, 2, 394, 396, 7, 86, 2, 2, 395, 397, 7, 122, 2, 2, 396, 395, 3,
	2, 2, 2, 396, 397, 3, 2, 2, 2, 397, 398, 3, 2, 2, 2, 398, 399, 5, 148,
	75, 2, 399, 51, 3, 2, 2, 2, 400, 402, 7, 72, 2, 2, 401, 403, 7, 122, 2,
	2, 402, 401, 3, 2, 2, 2, 402, 403, 3, 2, 2, 2, 403, 404, 3, 2, 2, 2, 404,
	405, 5, 148, 75, 2, 405, 53, 3, 2, 2, 2, 406, 408, 7, 84, 2, 2, 407, 409,
	5, 118, 60, 2, 408, 407, 3, 2, 2, 2, 408, 409, 3, 2, 2, 2, 409, 410, 3,
	2, 2, 2, 410, 411, 5, 148, 75, 2, 411, 55, 3, 2, 2, 2, 412, 414, 7, 121,
	2, 2, 413, 415, 5, 118, 60, 2, 414, 413, 3, 2, 2, 2, 414, 415, 3, 2, 2,
	2, 415, 416, 3, 2, 2, 2, 416, 417, 5, 148, 75, 2, 417, 57, 3, 2, 2, 2,
	418, 419, 7, 94, 2, 2, 419, 420, 7, 9, 2, 2, 420, 421, 5, 118, 60, 2, 421,
	422, 7, 10, 2, 2, 422, 423, 5, 6, 4, 2, 423, 59, 3, 2, 2, 2, 424, 425,
	7, 89, 2, 2, 425, 426, 7, 9, 2, 2, 426, 427, 5, 118, 60, 2, 427, 428, 7,
	10, 2, 2, 428, 429, 5, 62, 32, 2, 429, 61, 3, 2, 2, 2, 430, 432, 7, 11,
	2, 2, 431, 433, 5, 64, 33, 2, 432, 431, 3, 2, 2, 2, 432, 433, 3, 2, 2,
	2, 433, 438, 3, 2, 2, 2, 434, 436, 5, 68, 35, 2, 435, 437, 5, 64, 33, 2,
	436, 435, 3, 2, 2, 2, 436, 437, 3, 2, 2, 2, 437, 439, 3, 2, 2, 2, 438,
	434, 3, 2, 2, 2, 438, 439, 3, 2, 2, 2, 439, 440, 3, 2, 2, 2, 440, 441,
	7, 12, 2, 2, 441, 63, 3, 2, 2, 2, 442, 444, 5, 66, 34, 2, 443, 442, 3,
	2, 2, 2, 444, 445, 3, 2, 2, 2, 445, 443, 3, 2, 2, 2, 445, 446, 3, 2, 2,
	2, 446, 65, 3, 2, 2, 2, 447, 448, 7, 78, 2, 2, 448, 449, 5, 118, 60, 2,
	449, 451, 7, 17, 2, 2, 450, 452, 5, 10, 6, 2, 451, 450, 3, 2, 2, 2, 451,
	452, 3, 2, 2, 2, 452, 465, 3, 2, 2, 2, 453, 455, 7, 78, 2, 2, 454, 456,
	7, 9, 2, 2, 455, 454, 3, 2, 2, 2, 455, 456, 3, 2, 2, 2, 456, 457, 3, 2,
	2, 2, 457, 459, 5, 120, 61, 2, 458, 460, 7, 10, 2, 2, 459, 458, 3, 2, 2,
	2, 459, 460, 3, 2, 2, 2, 460, 462, 3, 2, 2, 2, 461, 463, 5, 10, 6, 2, 462,
	461, 3, 2, 2, 2, 462, 463, 3, 2, 2, 2, 463, 465, 3, 2, 2, 2, 464, 447,
	3, 2, 2, 2, 464, 453, 3, 2, 2, 2, 465, 67, 3, 2, 2, 2, 466, 468, 7, 95,
	2, 2, 467, 469, 7, 17, 2, 2, 468, 467, 3, 2, 2, 2, 468, 469, 3, 2, 2, 2,
	469, 471, 3, 2, 2, 2, 470, 472, 5, 10, 6, 2, 471, 470, 3, 2, 2, 2, 471,
	472, 3, 2, 2, 2, 472, 69, 3, 2, 2, 2, 473, 474, 7, 122, 2, 2, 474, 475,
	7, 17, 2, 2, 475, 476, 5, 6, 4, 2, 476, 71, 3, 2, 2, 2, 477, 478, 7, 97,
	2, 2, 478, 479, 5, 118, 60, 2, 479, 480, 5, 148, 75, 2, 480, 486, 3, 2,
	2, 2, 481, 482, 7, 98, 2, 2, 482, 483, 5, 118, 60, 2, 483, 484, 5, 148,
	75, 2, 484, 486, 3, 2, 2, 2, 485, 477, 3, 2, 2, 2, 485, 481, 3, 2, 2, 2,
	486, 73, 3, 2, 2, 2, 487, 488, 7, 101, 2, 2, 488, 494, 5, 8, 5, 2, 489,
	491, 5, 76, 39, 2, 490, 492, 5, 78, 40, 2, 491, 490, 3, 2, 2, 2, 491, 492,
	3, 2, 2, 2, 492, 495, 3, 2, 2, 2, 493, 495, 5, 78, 40, 2, 494, 489, 3,
	2, 2, 2, 494, 493, 3, 2, 2, 2, 495, 75, 3, 2, 2, 2, 496, 502, 7, 82, 2,
	2, 497, 499, 7, 9, 2, 2, 498, 500, 5, 122, 62, 2, 499, 498, 3, 2, 2, 2,
	499, 500, 3, 2, 2, 2, 500, 501, 3, 2, 2, 2, 501, 503, 7, 10, 2, 2, 502,
	497, 3, 2, 2, 2, 502, 503, 3, 2, 2, 2, 503, 504, 3, 2, 2, 2, 504, 505,
	5, 8, 5, 2, 505, 77, 3, 2, 2, 2, 506, 507, 7, 83, 2, 2, 507, 508, 5, 8,
	5, 2, 508, 79, 3, 2, 2, 2, 509, 510, 7, 91, 2, 2, 510, 511, 5, 148, 75,
	2, 511, 81, 3, 2, 2, 2, 512, 514, 7, 111, 2, 2, 513, 512, 3, 2, 2, 2, 513,
	514, 3, 2, 2, 2, 514, 515, 3, 2, 2, 2, 515, 517, 7, 92, 2, 2, 516, 518,
	7, 26, 2, 2, 517, 516, 3, 2, 2, 2, 517, 518, 3, 2, 2, 2, 518, 519, 3, 2,
	2, 2, 519, 520, 7, 122, 2, 2, 520, 522, 7, 9, 2, 2, 521, 523, 5, 92, 47,
	2, 522, 521, 3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523, 524, 3, 2, 2, 2, 524,
	525, 7, 10, 2, 2, 525, 526, 7, 11, 2, 2, 526, 527, 5, 98, 50, 2, 527, 528,
	7, 12, 2, 2, 528, 83, 3, 2, 2, 2, 529, 530, 7, 104, 2, 2, 530, 531, 7,
	122, 2, 2, 531, 532, 5, 86, 44, 2, 532, 85, 3, 2, 2, 2, 533, 534, 7, 106,
	2, 2, 534, 536, 5, 120, 61, 2, 535, 533, 3, 2, 2, 2, 535, 536, 3, 2, 2,
	2, 536, 537, 3, 2, 2, 2, 537, 541, 7, 11, 2, 2, 538, 540, 5, 88, 45, 2,
	539, 538, 3, 2, 2, 2, 540, 543, 3, 2, 2, 2, 541, 539, 3, 2, 2, 2, 541,
	542, 3, 2, 2, 2, 542, 544, 3, 2, 2, 2, 543, 541, 3, 2, 2, 2, 544, 545,
	7, 12, 2, 2, 545, 87, 3, 2, 2, 2, 546, 548, 9, 3, 2, 2, 547, 546, 3, 2,
	2, 2, 548, 551, 3, 2, 2, 2, 549, 547, 3, 2, 2, 2, 549, 550, 3, 2, 2, 2,
	550, 552, 3, 2, 2, 2, 551, 549, 3, 2, 2, 2, 552, 562, 5, 90, 46, 2, 553,
	562, 5, 40, 21, 2, 554, 556, 7, 31, 2, 2, 555, 554, 3, 2, 2, 2, 555, 556,
	3, 2, 2, 2, 556, 557, 3, 2, 2, 2, 557, 558, 5, 112, 57, 2, 558, 559, 7,
	15, 2, 2, 559, 560, 5, 120, 61, 2, 560, 562, 3, 2, 2, 2, 561, 549, 3, 2,
	2, 2, 561, 553, 3, 2, 2, 2, 561, 555, 3, 2, 2, 2, 562, 89, 3, 2, 2, 2,
	563, 565, 7, 26, 2, 2, 564, 563, 3, 2, 2, 2, 564, 565, 3, 2, 2, 2, 565,
	567, 3, 2, 2, 2, 566, 568, 7, 31, 2, 2, 567, 566, 3, 2, 2, 2, 567, 568,
	3, 2, 2, 2, 568, 569, 3, 2, 2, 2, 569, 570, 5, 112, 57, 2, 570, 572, 7,
	9, 2, 2, 571, 573, 5, 92, 47, 2, 572, 571, 3, 2, 2, 2, 572, 573, 3, 2,
	2, 2, 573, 574, 3, 2, 2, 2, 574, 575, 7, 10, 2, 2, 575, 576, 7, 11, 2,
	2, 576, 577, 5, 98, 50, 2, 577, 578, 7, 12, 2, 2, 578, 609, 3, 2, 2, 2,
	579, 581, 7, 26, 2, 2, 580, 579, 3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581,
	583, 3, 2, 2, 2, 582, 584, 7, 31, 2, 2, 583, 582, 3, 2, 2, 2, 583, 584,
	3, 2, 2, 2, 584, 585, 3, 2, 2, 2, 585, 586, 5, 144, 73, 2, 586, 587, 7,
	9, 2, 2, 587, 588, 7, 10, 2, 2, 588, 589, 7, 11, 2, 2, 589, 590, 5, 98,
	50, 2, 590, 591, 7, 12, 2, 2, 591, 609, 3, 2, 2, 2, 592, 594, 7, 26, 2,
	2, 593, 592, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 596, 3, 2, 2, 2, 595,
	597, 7, 31, 2, 2, 596, 595, 3, 2, 2, 2, 596, 597, 3, 2, 2, 2, 597, 598,
	3, 2, 2, 2, 598, 599, 5, 146, 74, 2, 599, 601, 7, 9, 2, 2, 600, 602, 5,
	92, 47, 2, 601, 600, 3, 2, 2, 2, 601, 602, 3, 2, 2, 2, 602, 603, 3, 2,
	2, 2, 603, 604, 7, 10, 2, 2, 604, 605, 7, 11, 2, 2, 605, 606, 5, 98, 50,
	2, 606, 607, 7, 12, 2, 2, 607, 609, 3, 2, 2, 2, 608, 564, 3, 2, 2, 2, 608,
	580, 3, 2, 2, 2, 608, 593, 3, 2, 2, 2, 609, 91, 3, 2, 2, 2, 610, 615, 5,
	94, 48, 2, 611, 612, 7, 14, 2, 2, 612, 614, 5, 94, 48, 2, 613, 611, 3,
	2, 2, 2, 614, 617, 3, 2, 2, 2, 615, 613, 3, 2, 2, 2, 615, 616, 3, 2, 2,
	2, 616, 620, 3, 2, 2, 2, 617, 615, 3, 2, 2, 2, 618, 619, 7, 14, 2, 2, 619,
	621, 5, 96, 49, 2, 620, 618, 3, 2, 2, 2, 620, 621, 3, 2, 2, 2, 621, 624,
	3, 2, 2, 2, 622, 624, 5, 96, 49, 2, 623, 610, 3, 2, 2, 2, 623, 622, 3,
	2, 2, 2, 624, 93, 3, 2, 2, 2, 625, 628, 5, 122, 62, 2, 626, 627, 7, 15,
	2, 2, 627, 629, 5, 120, 61, 2, 628, 626, 3, 2, 2, 2, 628, 629, 3, 2, 2,
	2, 629, 95, 3, 2, 2, 2, 630, 631, 7, 18, 2, 2, 631, 632, 5, 120, 61, 2,
	632, 97, 3, 2, 2, 2, 633, 635, 5, 100, 51, 2, 634, 633, 3, 2, 2, 2, 634,
	635, 3, 2, 2, 2, 635, 99, 3, 2, 2, 2, 636, 638, 5, 4, 3, 2, 637, 636, 3,
	2, 2, 2, 638, 639, 3, 2, 2, 2, 639, 637, 3, 2, 2, 2, 639, 640, 3, 2, 2,
	2, 640, 101, 3, 2, 2, 2, 641, 642, 7, 7, 2, 2, 642, 643, 5, 104, 53, 2,
	643, 644, 7, 8, 2, 2, 644, 103, 3, 2, 2, 2, 645, 647, 7, 14, 2, 2, 646,
	645, 3, 2, 2, 2, 647, 650, 3, 2, 2, 2, 648, 646, 3, 2, 2, 2, 648, 649,
	3, 2, 2, 2, 649, 652, 3, 2, 2, 2, 650, 648, 3, 2, 2, 2, 651, 653, 5, 106,
	54, 2, 652, 651, 3, 2, 2, 2, 652, 653, 3, 2, 2, 2, 653, 662, 3, 2, 2, 2,
	654, 656, 7, 14, 2, 2, 655, 654, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657,
	655, 3, 2, 2, 2, 657, 658, 3, 2, 2, 2, 658, 659, 3, 2, 2, 2, 659, 661,
	5, 106, 54, 2, 660, 655, 3, 2, 2, 2, 661, 664, 3, 2, 2, 2, 662, 660, 3,
	2, 2, 2, 662, 663, 3, 2, 2, 2, 663, 668, 3, 2, 2, 2, 664, 662, 3, 2, 2,
	2, 665, 667, 7, 14, 2, 2, 666, 665, 3, 2, 2, 2, 667, 670, 3, 2, 2, 2, 668,
	666, 3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669, 105, 3, 2, 2, 2, 670, 668,
	3, 2, 2, 2, 671, 673, 7, 18, 2, 2, 672, 671, 3, 2, 2, 2, 672, 673, 3, 2,
	2, 2, 673, 674, 3, 2, 2, 2, 674, 675, 5, 120, 61, 2, 675, 107, 3, 2, 2,
	2, 676, 685, 7, 11, 2, 2, 677, 682, 5, 110, 56, 2, 678, 679, 7, 14, 2,
	2, 679, 681, 5, 110, 56, 2, 680, 678, 3, 2, 2, 2, 681, 684, 3, 2, 2, 2,
	682, 680, 3, 2, 2, 2, 682, 683, 3, 2, 2, 2, 683, 686, 3, 2, 2, 2, 684,
	682, 3, 2, 2, 2, 685, 677, 3, 2, 2, 2, 685, 686, 3, 2, 2, 2, 686, 688,
	3, 2, 2, 2, 687, 689, 7, 14, 2, 2, 688, 687, 3, 2, 2, 2, 688, 689, 3, 2,
	2, 2, 689, 690, 3, 2, 2, 2, 690, 691, 7, 12, 2, 2, 691, 109, 3, 2, 2, 2,
	692, 693, 5, 112, 57, 2, 693, 694, 7, 17, 2, 2, 694, 695, 5, 120, 61, 2,
	695, 738, 3, 2, 2, 2, 696, 697, 7, 7, 2, 2, 697, 698, 5, 120, 61, 2, 698,
	699, 7, 8, 2, 2, 699, 700, 7, 17, 2, 2, 700, 701, 5, 120, 61, 2, 701, 738,
	3, 2, 2, 2, 702, 704, 7, 111, 2, 2, 703, 702, 3, 2, 2, 2, 703, 704, 3,
	2, 2, 2, 704, 706, 3, 2, 2, 2, 705, 707, 7, 26, 2, 2, 706, 705, 3, 2, 2,
	2, 706, 707, 3, 2, 2, 2, 707, 708, 3, 2, 2, 2, 708, 709, 5, 112, 57, 2,
	709, 711, 7, 9, 2, 2, 710, 712, 5, 92, 47, 2, 711, 710, 3, 2, 2, 2, 711,
	712, 3, 2, 2, 2, 712, 713, 3, 2, 2, 2, 713, 714, 7, 10, 2, 2, 714, 715,
	7, 11, 2, 2, 715, 716, 5, 98, 50, 2, 716, 717, 7, 12, 2, 2, 717, 738, 3,
	2, 2, 2, 718, 719, 5, 144, 73, 2, 719, 720, 7, 9, 2, 2, 720, 721, 7, 10,
	2, 2, 721, 722, 7, 11, 2, 2, 722, 723, 5, 98, 50, 2, 723, 724, 7, 12, 2,
	2, 724, 738, 3, 2, 2, 2, 725, 726, 5, 146, 74, 2, 726, 727, 7, 9, 2, 2,
	727, 728, 5, 94, 48, 2, 728, 729, 7, 10, 2, 2, 729, 730, 7, 11, 2, 2, 730,
	731, 5, 98, 50, 2, 731, 732, 7, 12, 2, 2, 732, 738, 3, 2, 2, 2, 733, 735,
	7, 18, 2, 2, 734, 733, 3, 2, 2, 2, 734, 735, 3, 2, 2, 2, 735, 736, 3, 2,
	2, 2, 736, 738, 5, 120, 61, 2, 737, 692, 3, 2, 2, 2, 737, 696, 3, 2, 2,
	2, 737, 703, 3, 2, 2, 2, 737, 718, 3, 2, 2, 2, 737, 725, 3, 2, 2, 2, 737,
	734, 3, 2, 2, 2, 738, 111, 3, 2, 2, 2, 739, 747, 5, 138, 70, 2, 740, 747,
	7, 123, 2, 2, 741, 747, 5, 134, 68, 2, 742, 743, 7, 7, 2, 2, 743, 744,
	5, 120, 61, 2, 744, 745, 7, 8, 2, 2, 745, 747, 3, 2, 2, 2, 746, 739, 3,
	2, 2, 2, 746, 740, 3, 2, 2, 2, 746, 741, 3, 2, 2, 2, 746, 742, 3, 2, 2,
	2, 747, 113, 3, 2, 2, 2, 748, 760, 7, 9, 2, 2, 749, 754, 5, 116, 59, 2,
	750, 751, 7, 14, 2, 2, 751, 753, 5, 116, 59, 2, 752, 750, 3, 2, 2, 2, 753,
	756, 3, 2, 2, 2, 754, 752, 3, 2, 2, 2, 754, 755, 3, 2, 2, 2, 755, 758,
	3, 2, 2, 2, 756, 754, 3, 2, 2, 2, 757, 759, 7, 14, 2, 2, 758, 757, 3, 2,
	2, 2, 758, 759, 3, 2, 2, 2, 759, 761, 3, 2, 2, 2, 760, 749, 3, 2, 2, 2,
	760, 761, 3, 2, 2, 2, 761, 762, 3, 2, 2, 2, 762, 763, 7, 10, 2, 2, 763,
	115, 3, 2, 2, 2, 764, 766, 7, 18, 2, 2, 765, 764, 3, 2, 2, 2, 765, 766,
	3, 2, 2, 2, 766, 769, 3, 2, 2, 2, 767, 770, 5, 120, 61, 2, 768, 770, 7,
	122, 2, 2, 769, 767, 3, 2, 2, 2, 769, 768, 3, 2, 2, 2, 770, 117, 3, 2,
	2, 2, 771, 776, 5, 120, 61, 2, 772, 773, 7, 14, 2, 2, 773, 775, 5, 120,
	61, 2, 774, 772, 3, 2, 2, 2, 775, 778, 3, 2, 2, 2, 776, 774, 3, 2, 2, 2,
	776, 777, 3, 2, 2, 2, 777, 119, 3, 2, 2, 2, 778, 776, 3, 2, 2, 2, 779,
	780, 8, 61, 1, 2, 780, 831, 5, 124, 63, 2, 781, 783, 7, 104, 2, 2, 782,
	784, 7, 122, 2, 2, 783, 782, 3, 2, 2, 2, 783, 784, 3, 2, 2, 2, 784, 785,
	3, 2, 2, 2, 785, 831, 5, 86, 44, 2, 786, 787, 7, 80, 2, 2, 787, 789, 5,
	120, 61, 2, 788, 790, 5, 114, 58, 2, 789, 788, 3, 2, 2, 2, 789, 790, 3,
	2, 2, 2, 790, 831, 3, 2, 2, 2, 791, 792, 7, 80, 2, 2, 792, 793, 7, 19,
	2, 2, 793, 831, 7, 122, 2, 2, 794, 795, 7, 99, 2, 2, 795, 831, 5, 120,
	61, 39, 796, 797, 7, 85, 2, 2, 797, 831, 5, 120, 61, 38, 798, 799, 7, 77,
	2, 2, 799, 831, 5, 120, 61, 37, 800, 801, 7, 20, 2, 2, 801, 831, 5, 120,
	61, 36, 802, 803, 7, 21, 2, 2, 803, 831, 5, 120, 61, 35, 804, 805, 7, 22,
	2, 2, 805, 831, 5, 120, 61, 34, 806, 807, 7, 23, 2, 2, 807, 831, 5, 120,
	61, 33, 808, 809, 7, 24, 2, 2, 809, 831, 5, 120, 61, 32, 810, 811, 7, 25,
	2, 2, 811, 831, 5, 120, 61, 31, 812, 813, 7, 112, 2, 2, 813, 831, 5, 120,
	61, 30, 814, 815, 7, 110, 2, 2, 815, 816, 7, 9, 2, 2, 816, 817, 5, 120,
	61, 2, 817, 818, 7, 10, 2, 2, 818, 831, 3, 2, 2, 2, 819, 831, 5, 56, 29,
	2, 820, 831, 7, 93, 2, 2, 821, 831, 7, 122, 2, 2, 822, 831, 7, 107, 2,
	2, 823, 831, 5, 132, 67, 2, 824, 831, 5, 102, 52, 2, 825, 831, 5, 108,
	55, 2, 826, 827, 7, 9, 2, 2, 827, 828, 5, 118, 60, 2, 828, 829, 7, 10,
	2, 2, 829, 831, 3, 2, 2, 2, 830, 779, 3, 2, 2, 2, 830, 781, 3, 2, 2, 2,
	830, 786, 3, 2, 2, 2, 830, 791, 3, 2, 2, 2, 830, 794, 3, 2, 2, 2, 830,
	796, 3, 2, 2, 2, 830, 798, 3, 2, 2, 2, 830, 800, 3, 2, 2, 2, 830, 802,
	3, 2, 2, 2, 830, 804, 3, 2, 2, 2, 830, 806, 3, 2, 2, 2, 830, 808, 3, 2,
	2, 2, 830, 810, 3, 2, 2, 2, 830, 812, 3, 2, 2, 2, 830, 814, 3, 2, 2, 2,
	830, 819, 3, 2, 2, 2, 830, 820, 3, 2, 2, 2, 830, 821, 3, 2, 2, 2, 830,
	822, 3, 2, 2, 2, 830, 823, 3, 2, 2, 2, 830, 824, 3, 2, 2, 2, 830, 825,
	3, 2, 2, 2, 830, 826, 3, 2, 2, 2, 831, 911, 3, 2, 2, 2, 832, 833, 12, 29,
	2, 2, 833, 834, 7, 29, 2, 2, 834, 910, 5, 120, 61, 29, 835, 836, 12, 28,
	2, 2, 836, 837, 9, 4, 2, 2, 837, 910, 5, 120, 61, 29, 838, 839, 12, 27,
	2, 2, 839, 840, 9, 5, 2, 2, 840, 910, 5, 120, 61, 28, 841, 842, 12, 26,
	2, 2, 842, 843, 7, 30, 2, 2, 843, 910, 5, 120, 61, 27, 844, 845, 12, 25,
	2, 2, 845, 846, 9, 6, 2, 2, 846, 910, 5, 120, 61, 26, 847, 848, 12, 24,
	2, 2, 848, 849, 9, 7, 2, 2, 849, 910, 5, 120, 61, 25, 850, 851, 12, 23,
	2, 2, 851, 852, 7, 76, 2, 2, 852, 910, 5, 120, 61, 24, 853, 854, 12, 22,
	2, 2, 854, 855, 7, 100, 2, 2, 855, 910, 5, 120, 61, 23, 856, 857, 12, 21,
	2, 2, 857, 858, 9, 8, 2, 2, 858, 910, 5, 120, 61, 22, 859, 860, 12, 20,
	2, 2, 860, 861, 7, 43, 2, 2, 861, 910, 5, 120, 61, 21, 862, 863, 12, 19,
	2, 2, 863, 864, 7, 44, 2, 2, 864, 910, 5, 120, 61, 20, 865, 866, 12, 18,
	2, 2, 866, 867, 7, 45, 2, 2, 867, 910, 5, 120, 61, 19, 868, 869, 12, 17,
	2, 2, 869, 870, 7, 46, 2, 2, 870, 910, 5, 120, 61, 18, 871, 872, 12, 16,
	2, 2, 872, 873, 7, 47, 2, 2, 873, 910, 5, 120, 61, 17, 874, 875, 12, 15,
	2, 2, 875, 876, 7, 16, 2, 2, 876, 877, 5, 120, 61, 2, 877, 878, 7, 17,
	2, 2, 878, 879, 5, 120, 61, 16, 879, 910, 3, 2, 2, 2, 880, 881, 12, 14,
	2, 2, 881, 882, 7, 15, 2, 2, 882, 910, 5, 120, 61, 14, 883, 884, 12, 13,
	2, 2, 884, 885, 5, 130, 66, 2, 885, 886, 5, 120, 61, 13, 886, 910, 3, 2,
	2, 2, 887, 888, 12, 46, 2, 2, 888, 889, 7, 7, 2, 2, 889, 890, 5, 118, 60,
	2, 890, 891, 7, 8, 2, 2, 891, 910, 3, 2, 2, 2, 892, 894, 12, 45, 2, 2,
	893, 895, 7, 16, 2, 2, 894, 893, 3, 2, 2, 2, 894, 895, 3, 2, 2, 2, 895,
	896, 3, 2, 2, 2, 896, 898, 7, 19, 2, 2, 897, 899, 7, 31, 2, 2, 898, 897,
	3, 2, 2, 2, 898, 899, 3, 2, 2, 2, 899, 900, 3, 2, 2, 2, 900, 910, 5, 138,
	70, 2, 901, 902, 12, 44, 2, 2, 902, 910, 5, 114, 58, 2, 903, 904, 12, 41,
	2, 2, 904, 910, 7, 20, 2, 2, 905, 906, 12, 40, 2, 2, 906, 910, 7, 21, 2,
	2, 907, 908, 12, 11, 2, 2, 908, 910, 7, 124, 2, 2, 909, 832, 3, 2, 2, 2,
	909, 835, 3, 2, 2, 2, 909, 838, 3, 2, 2, 2, 909, 841, 3, 2, 2, 2, 909,
	844, 3, 2, 2, 2, 909, 847, 3, 2, 2, 2, 909, 850, 3, 2, 2, 2, 909, 853,
	3, 2, 2, 2, 909, 856, 3, 2, 2, 2, 909, 859, 3, 2, 2, 2, 909, 862, 3, 2,
	2, 2, 909, 865, 3, 2, 2, 2, 909, 868, 3, 2, 2, 2, 909, 871, 3, 2, 2, 2,
	909, 874, 3, 2, 2, 2, 909, 880, 3, 2, 2, 2, 909, 883, 3, 2, 2, 2, 909,
	887, 3, 2, 2, 2, 909, 892, 3, 2, 2, 2, 909, 901, 3, 2, 2, 2, 909, 903,
	3, 2, 2, 2, 909, 905, 3, 2, 2, 2, 909, 907, 3, 2, 2, 2, 910, 913, 3, 2,
	2, 2, 911, 909, 3, 2, 2, 2, 911, 912, 3, 2, 2, 2, 912, 121, 3, 2, 2, 2,
	913, 911, 3, 2, 2, 2, 914, 918, 7, 122, 2, 2, 915, 918, 5, 102, 52, 2,
	916, 918, 5, 108, 55, 2, 917, 914, 3, 2, 2, 2, 917, 915, 3, 2, 2, 2, 917,
	916, 3, 2, 2, 2, 918, 123, 3, 2, 2, 2, 919, 944, 5, 82, 42, 2, 920, 922,
	7, 111, 2, 2, 921, 920, 3, 2, 2, 2, 921, 922, 3, 2, 2, 2, 922, 923, 3,
	2, 2, 2, 923, 925, 7, 92, 2, 2, 924, 926, 7, 26, 2, 2, 925, 924, 3, 2,
	2, 2, 925, 926, 3, 2, 2, 2, 926, 927, 3, 2, 2, 2, 927, 929, 7, 9, 2, 2,
	928, 930, 5, 92, 47, 2, 929, 928, 3, 2, 2, 2, 929, 930, 3, 2, 2, 2, 930,
	931, 3, 2, 2, 2, 931, 932, 7, 10, 2, 2, 932, 933, 7, 11, 2, 2, 933, 934,
	5, 98, 50, 2, 934, 935, 7, 12, 2, 2, 935, 944, 3, 2, 2, 2, 936, 938, 7,
	111, 2, 2, 937, 936, 3, 2, 2, 2, 937, 938, 3, 2, 2, 2, 938, 939, 3, 2,
	2, 2, 939, 940, 5, 126, 64, 2, 940, 941, 7, 60, 2, 2, 941, 942, 5, 128,
	65, 2, 942, 944, 3, 2, 2, 2, 943, 919, 3, 2, 2, 2, 943, 921, 3, 2, 2, 2,
	943, 937, 3, 2, 2, 2, 944, 125, 3, 2, 2, 2, 945, 952, 7, 122, 2, 2, 946,
	948, 7, 9, 2, 2, 947, 949, 5, 92, 47, 2, 948, 947, 3, 2, 2, 2, 948, 949,
	3, 2, 2, 2, 949, 950, 3, 2, 2, 2, 950, 952, 7, 10, 2, 2, 951, 945, 3, 2,
	2, 2, 951, 946, 3, 2, 2, 2, 952, 127, 3, 2, 2, 2, 953, 959, 5, 120, 61,
	2, 954, 955, 7, 11, 2, 2, 955, 956, 5, 98, 50, 2, 956, 957, 7, 12, 2, 2,
	957, 959, 3, 2, 2, 2, 958, 953, 3, 2, 2, 2, 958, 954, 3, 2, 2, 2, 959,
	129, 3, 2, 2, 2, 960, 961, 9, 9, 2, 2, 961, 131, 3, 2, 2, 2, 962, 970,
	7, 61, 2, 2, 963, 970, 7, 62, 2, 2, 964, 970, 7, 123, 2, 2, 965, 970, 7,
	124, 2, 2, 966, 970, 7, 6, 2, 2, 967, 970, 5, 134, 68, 2, 968, 970, 5,
	136, 69, 2, 969, 962, 3, 2, 2, 2, 969, 963, 3, 2, 2, 2, 969, 964, 3, 2,
	2, 2, 969, 965, 3, 2, 2, 2, 969, 966, 3, 2, 2, 2, 969, 967, 3, 2, 2, 2,
	969, 968, 3, 2, 2, 2, 970, 133, 3, 2, 2, 2, 971, 972, 9, 10, 2, 2, 972,
	135, 3, 2, 2, 2, 973, 974, 9, 11, 2, 2, 974, 137, 3, 2, 2, 2, 975, 978,
	7, 122, 2, 2, 976, 978, 5, 140, 71, 2, 977, 975, 3, 2, 2, 2, 977, 976,
	3, 2, 2, 2, 978, 139, 3, 2, 2, 2, 979, 983, 5, 142, 72, 2, 980, 983, 7,
	61, 2, 2, 981, 983, 7, 62, 2, 2, 982, 979, 3, 2, 2, 2, 982, 980, 3, 2,
	2, 2, 982, 981, 3, 2, 2, 2, 983, 141, 3, 2, 2, 2, 984, 985, 9, 12, 2, 2,
	985, 143, 3, 2, 2, 2, 986, 987, 7, 122, 2, 2, 987, 988, 5, 112, 57, 2,
	988, 145, 3, 2, 2, 2, 989, 990, 7, 122, 2, 2, 990, 991, 5, 112, 57, 2,
	991, 147, 3, 2, 2, 2, 992, 993, 9, 13, 2, 2, 993, 149, 3, 2, 2, 2, 119,
	151, 154, 180, 184, 191, 198, 201, 203, 206, 210, 217, 225, 230, 232, 242,
	250, 255, 264, 272, 276, 281, 292, 298, 302, 305, 308, 324, 344, 348, 352,
	360, 369, 374, 390, 396, 402, 408, 414, 432, 436, 438, 445, 451, 455, 459,
	462, 464, 468, 471, 485, 491, 494, 499, 502, 513, 517, 522, 535, 541, 549,
	555, 561, 564, 567, 572, 580, 583, 593, 596, 601, 608, 615, 620, 623, 628,
	634, 639, 648, 652, 657, 662, 668, 672, 682, 685, 688, 703, 706, 711, 734,
	737, 746, 754, 758, 760, 765, 769, 776, 783, 789, 830, 894, 898, 909, 911,
	917, 921, 925, 929, 937, 943, 948, 951, 958, 969, 977, 982,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "'['", "']'", "'('", "')'", "'{'", "'}'", "';'", "','",
	"'='", "'?'", "':'", "'...'", "'.'", "'++'", "'--'", "'+'", "'-'", "'~'",
	"'!'", "'*'", "'/'", "'%'", "'**'", "'??'", "'#'", "'>>'", "'<<'", "'>>>'",
	"'<'", "'>'", "'<='", "'>='", "'=='", "'!='", "'==='", "'!=='", "'&'",
	"'^'", "'|'", "'&&'", "'||'", "'*='", "'/='", "'%='", "'+='", "'-='", "'<<='",
	"'>>='", "'>>>='", "'&='", "'^='", "'|='", "'**='", "'=>'", "'null'", "",
	"", "", "", "", "", "", "", "", "", "'break'", "'do'", "'collectionof'",
	"'elementsof'", "'instanceof'", "'typeof'", "'case'", "'else'", "'new'",
	"'var'", "'catch'", "'finally'", "'return'", "'void'", "'continue'", "'for'",
	"'foreach'", "'switch'", "'while'", "'debugger'", "'function'", "'this'",
	"'with'", "'default'", "'if'", "'throw'", "'raise'", "'delete'", "'in'",
	"'try'", "'as'", "'from'", "'class'", "'enum'", "'extends'", "'super'",
	"'const'", "'export'", "'import'", "'async'", "'await'", "'implements'",
	"'let'", "'private'", "'public'", "'interface'", "'package'", "'protected'",
	"'static'", "'yield'",
}
var symbolicNames = []string{
	"", "HashBangLine", "MultiLineComment", "SingleLineComment", "RegularExpressionLiteral",
	"OpenBracket", "CloseBracket", "OpenParen", "CloseParen", "OpenBrace",
	"CloseBrace", "SemiColon", "Comma", "Assign", "QuestionMark", "Colon",
	"Ellipsis", "Dot", "PlusPlus", "MinusMinus", "Plus", "Minus", "BitNot",
	"Not", "Multiply", "Divide", "Modulus", "Power", "NullCoalesce", "Hashtag",
	"RightShiftArithmetic", "LeftShiftArithmetic", "RightShiftLogical", "LessThan",
	"MoreThan", "LessThanEquals", "GreaterThanEquals", "Equals_", "NotEquals",
	"IdentityEquals", "IdentityNotEquals", "BitAnd", "BitXOr", "BitOr", "And",
	"Or", "MultiplyAssign", "DivideAssign", "ModulusAssign", "PlusAssign",
	"MinusAssign", "LeftShiftArithmeticAssign", "RightShiftArithmeticAssign",
	"RightShiftLogicalAssign", "BitAndAssign", "BitXorAssign", "BitOrAssign",
	"PowerAssign", "ARROW", "NullLiteral", "BooleanLiteral", "DecimalLiteral",
	"HexIntegerLiteral", "OctalIntegerLiteral", "OctalIntegerLiteral2", "BinaryIntegerLiteral",
	"BigHexIntegerLiteral", "BigOctalIntegerLiteral", "BigBinaryIntegerLiteral",
	"BigDecimalIntegerLiteral", "Break", "Do", "CollectionOf", "ElementOf",
	"Instanceof", "Typeof", "Case", "Else", "New", "Var", "Catch", "Finally",
	"Return", "Void", "Continue", "For", "Foreach", "Switch", "While", "Debugger",
	"Function", "This", "With", "Default", "If", "Throw", "Raise", "Delete",
	"In", "Try", "As", "From", "Class", "Enum", "Extends", "Super", "Const",
	"Export", "Import", "Async", "Await", "Implements", "Let", "Private", "Public",
	"Interface", "Package", "Protected", "Static", "Yield", "Identifier", "StringLiteral",
	"TemplateStringLiteral", "WhiteSpaces", "LineTerminator", "HtmlComment",
	"CDataComment", "UnexpectedCharacter",
}

var ruleNames = []string{
	"program", "sourceElement", "statement", "block", "statementList", "importStatement",
	"importFromBlock", "moduleItems", "importDefault", "importNamespace", "importFrom",
	"aliasName", "exportStatement", "exportFromBlock", "declaration", "variableStatement",
	"variableDeclarationList", "variableDeclaration", "variableType", "emptyStatement",
	"expressionStatement", "ifStatement", "iterationStatement", "varModifier",
	"continueStatement", "breakStatement", "returnStatement", "yieldStatement",
	"withStatement", "switchStatement", "caseBlock", "caseClauses", "caseClause",
	"defaultClause", "labelledStatement", "throwStatement", "tryStatement",
	"catchProduction", "finallyProduction", "debuggerStatement", "functionDeclaration",
	"classDeclaration", "classTail", "classElement", "methodDefinition", "formalParameterList",
	"formalParameterArg", "lastFormalParameterArg", "functionBody", "sourceElements",
	"arrayLiteral", "elementList", "arrayElement", "objectLiteral", "propertyAssignment",
	"propertyName", "arguments", "argument", "expressionSequence", "singleExpression",
	"assignable", "anoymousFunction", "arrowFunctionParameters", "arrowFunctionBody",
	"assignmentOperator", "literal", "numericLiteral", "bigintLiteral", "identifierName",
	"reservedWord", "keyword", "getter", "setter", "eos",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type ABSLParser struct {
	*antlr.BaseParser
}

func NewABSLParser(input antlr.TokenStream) *ABSLParser {
	this := new(ABSLParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ABSLParser.g4"

	return this
}

// ABSLParser tokens.
const (
	ABSLParserEOF                        = antlr.TokenEOF
	ABSLParserHashBangLine               = 1
	ABSLParserMultiLineComment           = 2
	ABSLParserSingleLineComment          = 3
	ABSLParserRegularExpressionLiteral   = 4
	ABSLParserOpenBracket                = 5
	ABSLParserCloseBracket               = 6
	ABSLParserOpenParen                  = 7
	ABSLParserCloseParen                 = 8
	ABSLParserOpenBrace                  = 9
	ABSLParserCloseBrace                 = 10
	ABSLParserSemiColon                  = 11
	ABSLParserComma                      = 12
	ABSLParserAssign                     = 13
	ABSLParserQuestionMark               = 14
	ABSLParserColon                      = 15
	ABSLParserEllipsis                   = 16
	ABSLParserDot                        = 17
	ABSLParserPlusPlus                   = 18
	ABSLParserMinusMinus                 = 19
	ABSLParserPlus                       = 20
	ABSLParserMinus                      = 21
	ABSLParserBitNot                     = 22
	ABSLParserNot                        = 23
	ABSLParserMultiply                   = 24
	ABSLParserDivide                     = 25
	ABSLParserModulus                    = 26
	ABSLParserPower                      = 27
	ABSLParserNullCoalesce               = 28
	ABSLParserHashtag                    = 29
	ABSLParserRightShiftArithmetic       = 30
	ABSLParserLeftShiftArithmetic        = 31
	ABSLParserRightShiftLogical          = 32
	ABSLParserLessThan                   = 33
	ABSLParserMoreThan                   = 34
	ABSLParserLessThanEquals             = 35
	ABSLParserGreaterThanEquals          = 36
	ABSLParserEquals_                    = 37
	ABSLParserNotEquals                  = 38
	ABSLParserIdentityEquals             = 39
	ABSLParserIdentityNotEquals          = 40
	ABSLParserBitAnd                     = 41
	ABSLParserBitXOr                     = 42
	ABSLParserBitOr                      = 43
	ABSLParserAnd                        = 44
	ABSLParserOr                         = 45
	ABSLParserMultiplyAssign             = 46
	ABSLParserDivideAssign               = 47
	ABSLParserModulusAssign              = 48
	ABSLParserPlusAssign                 = 49
	ABSLParserMinusAssign                = 50
	ABSLParserLeftShiftArithmeticAssign  = 51
	ABSLParserRightShiftArithmeticAssign = 52
	ABSLParserRightShiftLogicalAssign    = 53
	ABSLParserBitAndAssign               = 54
	ABSLParserBitXorAssign               = 55
	ABSLParserBitOrAssign                = 56
	ABSLParserPowerAssign                = 57
	ABSLParserARROW                      = 58
	ABSLParserNullLiteral                = 59
	ABSLParserBooleanLiteral             = 60
	ABSLParserDecimalLiteral             = 61
	ABSLParserHexIntegerLiteral          = 62
	ABSLParserOctalIntegerLiteral        = 63
	ABSLParserOctalIntegerLiteral2       = 64
	ABSLParserBinaryIntegerLiteral       = 65
	ABSLParserBigHexIntegerLiteral       = 66
	ABSLParserBigOctalIntegerLiteral     = 67
	ABSLParserBigBinaryIntegerLiteral    = 68
	ABSLParserBigDecimalIntegerLiteral   = 69
	ABSLParserBreak                      = 70
	ABSLParserDo                         = 71
	ABSLParserCollectionOf               = 72
	ABSLParserElementOf                  = 73
	ABSLParserInstanceof                 = 74
	ABSLParserTypeof                     = 75
	ABSLParserCase                       = 76
	ABSLParserElse                       = 77
	ABSLParserNew                        = 78
	ABSLParserVar                        = 79
	ABSLParserCatch                      = 80
	ABSLParserFinally                    = 81
	ABSLParserReturn                     = 82
	ABSLParserVoid                       = 83
	ABSLParserContinue                   = 84
	ABSLParserFor                        = 85
	ABSLParserForeach                    = 86
	ABSLParserSwitch                     = 87
	ABSLParserWhile                      = 88
	ABSLParserDebugger                   = 89
	ABSLParserFunction                   = 90
	ABSLParserThis                       = 91
	ABSLParserWith                       = 92
	ABSLParserDefault                    = 93
	ABSLParserIf                         = 94
	ABSLParserThrow                      = 95
	ABSLParserRaise                      = 96
	ABSLParserDelete                     = 97
	ABSLParserIn                         = 98
	ABSLParserTry                        = 99
	ABSLParserAs                         = 100
	ABSLParserFrom                       = 101
	ABSLParserClass                      = 102
	ABSLParserEnum                       = 103
	ABSLParserExtends                    = 104
	ABSLParserSuper                      = 105
	ABSLParserConst                      = 106
	ABSLParserExport                     = 107
	ABSLParserImport                     = 108
	ABSLParserAsync                      = 109
	ABSLParserAwait                      = 110
	ABSLParserImplements                 = 111
	ABSLParserLet                        = 112
	ABSLParserPrivate                    = 113
	ABSLParserPublic                     = 114
	ABSLParserInterface                  = 115
	ABSLParserPackage                    = 116
	ABSLParserProtected                  = 117
	ABSLParserStatic                     = 118
	ABSLParserYield                      = 119
	ABSLParserIdentifier                 = 120
	ABSLParserStringLiteral              = 121
	ABSLParserTemplateStringLiteral      = 122
	ABSLParserWhiteSpaces                = 123
	ABSLParserLineTerminator             = 124
	ABSLParserHtmlComment                = 125
	ABSLParserCDataComment               = 126
	ABSLParserUnexpectedCharacter        = 127
)

// ABSLParser rules.
const (
	ABSLParserRULE_program                 = 0
	ABSLParserRULE_sourceElement           = 1
	ABSLParserRULE_statement               = 2
	ABSLParserRULE_block                   = 3
	ABSLParserRULE_statementList           = 4
	ABSLParserRULE_importStatement         = 5
	ABSLParserRULE_importFromBlock         = 6
	ABSLParserRULE_moduleItems             = 7
	ABSLParserRULE_importDefault           = 8
	ABSLParserRULE_importNamespace         = 9
	ABSLParserRULE_importFrom              = 10
	ABSLParserRULE_aliasName               = 11
	ABSLParserRULE_exportStatement         = 12
	ABSLParserRULE_exportFromBlock         = 13
	ABSLParserRULE_declaration             = 14
	ABSLParserRULE_variableStatement       = 15
	ABSLParserRULE_variableDeclarationList = 16
	ABSLParserRULE_variableDeclaration     = 17
	ABSLParserRULE_variableType            = 18
	ABSLParserRULE_emptyStatement          = 19
	ABSLParserRULE_expressionStatement     = 20
	ABSLParserRULE_ifStatement             = 21
	ABSLParserRULE_iterationStatement      = 22
	ABSLParserRULE_varModifier             = 23
	ABSLParserRULE_continueStatement       = 24
	ABSLParserRULE_breakStatement          = 25
	ABSLParserRULE_returnStatement         = 26
	ABSLParserRULE_yieldStatement          = 27
	ABSLParserRULE_withStatement           = 28
	ABSLParserRULE_switchStatement         = 29
	ABSLParserRULE_caseBlock               = 30
	ABSLParserRULE_caseClauses             = 31
	ABSLParserRULE_caseClause              = 32
	ABSLParserRULE_defaultClause           = 33
	ABSLParserRULE_labelledStatement       = 34
	ABSLParserRULE_throwStatement          = 35
	ABSLParserRULE_tryStatement            = 36
	ABSLParserRULE_catchProduction         = 37
	ABSLParserRULE_finallyProduction       = 38
	ABSLParserRULE_debuggerStatement       = 39
	ABSLParserRULE_functionDeclaration     = 40
	ABSLParserRULE_classDeclaration        = 41
	ABSLParserRULE_classTail               = 42
	ABSLParserRULE_classElement            = 43
	ABSLParserRULE_methodDefinition        = 44
	ABSLParserRULE_formalParameterList     = 45
	ABSLParserRULE_formalParameterArg      = 46
	ABSLParserRULE_lastFormalParameterArg  = 47
	ABSLParserRULE_functionBody            = 48
	ABSLParserRULE_sourceElements          = 49
	ABSLParserRULE_arrayLiteral            = 50
	ABSLParserRULE_elementList             = 51
	ABSLParserRULE_arrayElement            = 52
	ABSLParserRULE_objectLiteral           = 53
	ABSLParserRULE_propertyAssignment      = 54
	ABSLParserRULE_propertyName            = 55
	ABSLParserRULE_arguments               = 56
	ABSLParserRULE_argument                = 57
	ABSLParserRULE_expressionSequence      = 58
	ABSLParserRULE_singleExpression        = 59
	ABSLParserRULE_assignable              = 60
	ABSLParserRULE_anoymousFunction        = 61
	ABSLParserRULE_arrowFunctionParameters = 62
	ABSLParserRULE_arrowFunctionBody       = 63
	ABSLParserRULE_assignmentOperator      = 64
	ABSLParserRULE_literal                 = 65
	ABSLParserRULE_numericLiteral          = 66
	ABSLParserRULE_bigintLiteral           = 67
	ABSLParserRULE_identifierName          = 68
	ABSLParserRULE_reservedWord            = 69
	ABSLParserRULE_keyword                 = 70
	ABSLParserRULE_getter                  = 71
	ABSLParserRULE_setter                  = 72
	ABSLParserRULE_eos                     = 73
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_program
	return p
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(ABSLParserEOF, 0)
}

func (s *ProgramContext) HashBangLine() antlr.TerminalNode {
	return s.GetToken(ABSLParserHashBangLine, 0)
}

func (s *ProgramContext) SourceElements() ISourceElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ABSLParserRULE_program)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(149)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserHashBangLine {
		{
			p.SetState(148)
			p.Match(ABSLParserHashBangLine)
		}

	}
	p.SetState(152)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserSemiColon)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserForeach-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserRaise-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(151)
			p.SourceElements()
		}

	}
	{
		p.SetState(154)
		p.Match(ABSLParserEOF)
	}

	return localctx
}

// ISourceElementContext is an interface to support dynamic dispatch.
type ISourceElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceElementContext differentiates from other interfaces.
	IsSourceElementContext()
}

type SourceElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementContext() *SourceElementContext {
	var p = new(SourceElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_sourceElement
	return p
}

func (*SourceElementContext) IsSourceElementContext() {}

func NewSourceElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementContext {
	var p = new(SourceElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_sourceElement

	return p
}

func (s *SourceElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SourceElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterSourceElement(s)
	}
}

func (s *SourceElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitSourceElement(s)
	}
}

func (s *SourceElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitSourceElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) SourceElement() (localctx ISourceElementContext) {
	localctx = NewSourceElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ABSLParserRULE_sourceElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(156)
		p.Statement()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) VariableStatement() IVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *StatementContext) ImportStatement() IImportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) EmptyStatement() IEmptyStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmptyStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmptyStatementContext)
}

func (s *StatementContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIterationStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinueStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreakStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) YieldStatement() IYieldStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *StatementContext) WithStatement() IWithStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *StatementContext) LabelledStatement() ILabelledStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabelledStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabelledStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrowStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) DebuggerStatement() IDebuggerStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDebuggerStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDebuggerStatementContext)
}

func (s *StatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ABSLParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(178)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(158)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(159)
			p.VariableStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(160)
			p.ImportStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(161)
			p.ExportStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(162)
			p.EmptyStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(163)
			p.ClassDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(164)
			p.ExpressionStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(165)
			p.IfStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(166)
			p.IterationStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(167)
			p.ContinueStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(168)
			p.BreakStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(169)
			p.ReturnStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(170)
			p.YieldStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(171)
			p.WithStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(172)
			p.LabelledStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(173)
			p.SwitchStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(174)
			p.ThrowStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(175)
			p.TryStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(176)
			p.DebuggerStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(177)
			p.FunctionDeclaration()
		}

	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *BlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *BlockContext) StatementList() IStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ABSLParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(180)
		p.Match(ABSLParserOpenBrace)
	}
	p.SetState(182)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserSemiColon)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserForeach-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserRaise-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(181)
			p.StatementList()
		}

	}
	{
		p.SetState(184)
		p.Match(ABSLParserCloseBrace)
	}

	return localctx
}

// IStatementListContext is an interface to support dynamic dispatch.
type IStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementListContext differentiates from other interfaces.
	IsStatementListContext()
}

type StatementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementListContext() *StatementListContext {
	var p = new(StatementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_statementList
	return p
}

func (*StatementListContext) IsStatementListContext() {}

func NewStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementListContext {
	var p = new(StatementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_statementList

	return p
}

func (s *StatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementListContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *StatementListContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterStatementList(s)
	}
}

func (s *StatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitStatementList(s)
	}
}

func (s *StatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) StatementList() (localctx IStatementListContext) {
	localctx = NewStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ABSLParserRULE_statementList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(187)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserSemiColon)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserForeach-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserRaise-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(186)
			p.Statement()
		}

		p.SetState(189)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_importStatement
	return p
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) Import() antlr.TerminalNode {
	return s.GetToken(ABSLParserImport, 0)
}

func (s *ImportStatementContext) ImportFromBlock() IImportFromBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportFromBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportFromBlockContext)
}

func (s *ImportStatementContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ImportStatementContext) As() antlr.TerminalNode {
	return s.GetToken(ABSLParserAs, 0)
}

func (s *ImportStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ABSLParserRULE_importStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(201)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(191)
			p.Match(ABSLParserImport)
		}
		{
			p.SetState(192)
			p.ImportFromBlock()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(193)
			p.Match(ABSLParserImport)
		}
		{
			p.SetState(194)
			p.singleExpression(0)
		}
		p.SetState(196)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserAs {
			{
				p.SetState(195)
				p.Match(ABSLParserAs)
			}

		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(198)
				p.Match(ABSLParserIdentifier)
			}

		}

	}

	return localctx
}

// IImportFromBlockContext is an interface to support dynamic dispatch.
type IImportFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportFromBlockContext differentiates from other interfaces.
	IsImportFromBlockContext()
}

type ImportFromBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportFromBlockContext() *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_importFromBlock
	return p
}

func (*ImportFromBlockContext) IsImportFromBlockContext() {}

func NewImportFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportFromBlockContext {
	var p = new(ImportFromBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_importFromBlock

	return p
}

func (s *ImportFromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportFromBlockContext) ImportFrom() IImportFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ImportFromBlockContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ImportFromBlockContext) ImportNamespace() IImportNamespaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportNamespaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportNamespaceContext)
}

func (s *ImportFromBlockContext) ModuleItems() IModuleItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleItemsContext)
}

func (s *ImportFromBlockContext) ImportDefault() IImportDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportDefaultContext)
}

func (s *ImportFromBlockContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserStringLiteral, 0)
}

func (s *ImportFromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportFromBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterImportFromBlock(s)
	}
}

func (s *ImportFromBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitImportFromBlock(s)
	}
}

func (s *ImportFromBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitImportFromBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ImportFromBlock() (localctx IImportFromBlockContext) {
	localctx = NewImportFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ABSLParserRULE_importFromBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(215)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserOpenBrace, ABSLParserMultiply, ABSLParserNullLiteral, ABSLParserBooleanLiteral, ABSLParserBreak, ABSLParserDo, ABSLParserInstanceof, ABSLParserTypeof, ABSLParserCase, ABSLParserElse, ABSLParserNew, ABSLParserVar, ABSLParserCatch, ABSLParserFinally, ABSLParserReturn, ABSLParserVoid, ABSLParserContinue, ABSLParserFor, ABSLParserSwitch, ABSLParserWhile, ABSLParserDebugger, ABSLParserFunction, ABSLParserThis, ABSLParserWith, ABSLParserDefault, ABSLParserIf, ABSLParserThrow, ABSLParserDelete, ABSLParserIn, ABSLParserTry, ABSLParserAs, ABSLParserFrom, ABSLParserClass, ABSLParserEnum, ABSLParserExtends, ABSLParserSuper, ABSLParserConst, ABSLParserExport, ABSLParserImport, ABSLParserAsync, ABSLParserAwait, ABSLParserImplements, ABSLParserLet, ABSLParserPrivate, ABSLParserPublic, ABSLParserInterface, ABSLParserPackage, ABSLParserProtected, ABSLParserStatic, ABSLParserYield, ABSLParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserInstanceof-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserCase-59))|(1<<(ABSLParserElse-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserCatch-59))|(1<<(ABSLParserFinally-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserDefault-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserIn-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserAs-91))|(1<<(ABSLParserFrom-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserEnum-91))|(1<<(ABSLParserExtends-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserImplements-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserPrivate-91))|(1<<(ABSLParserPublic-91))|(1<<(ABSLParserInterface-91))|(1<<(ABSLParserPackage-91))|(1<<(ABSLParserProtected-91))|(1<<(ABSLParserStatic-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91)))) != 0) {
			{
				p.SetState(203)
				p.ImportDefault()
			}

		}
		p.SetState(208)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ABSLParserMultiply:
			{
				p.SetState(206)
				p.ImportNamespace()
			}

		case ABSLParserOpenBrace:
			{
				p.SetState(207)
				p.ModuleItems()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(210)
			p.ImportFrom()
		}
		{
			p.SetState(211)
			p.Eos()
		}

	case ABSLParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(213)
			p.Match(ABSLParserStringLiteral)
		}
		{
			p.SetState(214)
			p.Eos()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModuleItemsContext is an interface to support dynamic dispatch.
type IModuleItemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleItemsContext differentiates from other interfaces.
	IsModuleItemsContext()
}

type ModuleItemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleItemsContext() *ModuleItemsContext {
	var p = new(ModuleItemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_moduleItems
	return p
}

func (*ModuleItemsContext) IsModuleItemsContext() {}

func NewModuleItemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleItemsContext {
	var p = new(ModuleItemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_moduleItems

	return p
}

func (s *ModuleItemsContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleItemsContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *ModuleItemsContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *ModuleItemsContext) AllAliasName() []IAliasNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAliasNameContext)(nil)).Elem())
	var tst = make([]IAliasNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAliasNameContext)
		}
	}

	return tst
}

func (s *ModuleItemsContext) AliasName(i int) IAliasNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAliasNameContext)
}

func (s *ModuleItemsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserComma)
}

func (s *ModuleItemsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserComma, i)
}

func (s *ModuleItemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleItemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleItemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterModuleItems(s)
	}
}

func (s *ModuleItemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitModuleItems(s)
	}
}

func (s *ModuleItemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitModuleItems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ModuleItems() (localctx IModuleItemsContext) {
	localctx = NewModuleItemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ABSLParserRULE_moduleItems)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(217)
		p.Match(ABSLParserOpenBrace)
	}
	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(218)
				p.AliasName()
			}
			{
				p.SetState(219)
				p.Match(ABSLParserComma)
			}

		}
		p.SetState(225)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext())
	}
	p.SetState(230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserInstanceof-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserCase-59))|(1<<(ABSLParserElse-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserCatch-59))|(1<<(ABSLParserFinally-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserDefault-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserIn-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserAs-91))|(1<<(ABSLParserFrom-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserEnum-91))|(1<<(ABSLParserExtends-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserImplements-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserPrivate-91))|(1<<(ABSLParserPublic-91))|(1<<(ABSLParserInterface-91))|(1<<(ABSLParserPackage-91))|(1<<(ABSLParserProtected-91))|(1<<(ABSLParserStatic-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91)))) != 0) {
		{
			p.SetState(226)
			p.AliasName()
		}
		p.SetState(228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserComma {
			{
				p.SetState(227)
				p.Match(ABSLParserComma)
			}

		}

	}
	{
		p.SetState(232)
		p.Match(ABSLParserCloseBrace)
	}

	return localctx
}

// IImportDefaultContext is an interface to support dynamic dispatch.
type IImportDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportDefaultContext differentiates from other interfaces.
	IsImportDefaultContext()
}

type ImportDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDefaultContext() *ImportDefaultContext {
	var p = new(ImportDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_importDefault
	return p
}

func (*ImportDefaultContext) IsImportDefaultContext() {}

func NewImportDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDefaultContext {
	var p = new(ImportDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_importDefault

	return p
}

func (s *ImportDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDefaultContext) AliasName() IAliasNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasNameContext)
}

func (s *ImportDefaultContext) Comma() antlr.TerminalNode {
	return s.GetToken(ABSLParserComma, 0)
}

func (s *ImportDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterImportDefault(s)
	}
}

func (s *ImportDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitImportDefault(s)
	}
}

func (s *ImportDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitImportDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ImportDefault() (localctx IImportDefaultContext) {
	localctx = NewImportDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ABSLParserRULE_importDefault)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(234)
		p.AliasName()
	}
	{
		p.SetState(235)
		p.Match(ABSLParserComma)
	}

	return localctx
}

// IImportNamespaceContext is an interface to support dynamic dispatch.
type IImportNamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportNamespaceContext differentiates from other interfaces.
	IsImportNamespaceContext()
}

type ImportNamespaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportNamespaceContext() *ImportNamespaceContext {
	var p = new(ImportNamespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_importNamespace
	return p
}

func (*ImportNamespaceContext) IsImportNamespaceContext() {}

func NewImportNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportNamespaceContext {
	var p = new(ImportNamespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_importNamespace

	return p
}

func (s *ImportNamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportNamespaceContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ABSLParserMultiply, 0)
}

func (s *ImportNamespaceContext) As() antlr.TerminalNode {
	return s.GetToken(ABSLParserAs, 0)
}

func (s *ImportNamespaceContext) IdentifierName() IIdentifierNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *ImportNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportNamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterImportNamespace(s)
	}
}

func (s *ImportNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitImportNamespace(s)
	}
}

func (s *ImportNamespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitImportNamespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ImportNamespace() (localctx IImportNamespaceContext) {
	localctx = NewImportNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ABSLParserRULE_importNamespace)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		p.Match(ABSLParserMultiply)
	}
	p.SetState(240)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserAs {
		{
			p.SetState(238)
			p.Match(ABSLParserAs)
		}
		{
			p.SetState(239)
			p.IdentifierName()
		}

	}

	return localctx
}

// IImportFromContext is an interface to support dynamic dispatch.
type IImportFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportFromContext differentiates from other interfaces.
	IsImportFromContext()
}

type ImportFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportFromContext() *ImportFromContext {
	var p = new(ImportFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_importFrom
	return p
}

func (*ImportFromContext) IsImportFromContext() {}

func NewImportFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportFromContext {
	var p = new(ImportFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_importFrom

	return p
}

func (s *ImportFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportFromContext) From() antlr.TerminalNode {
	return s.GetToken(ABSLParserFrom, 0)
}

func (s *ImportFromContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserStringLiteral, 0)
}

func (s *ImportFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterImportFrom(s)
	}
}

func (s *ImportFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitImportFrom(s)
	}
}

func (s *ImportFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitImportFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ImportFrom() (localctx IImportFromContext) {
	localctx = NewImportFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ABSLParserRULE_importFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.Match(ABSLParserFrom)
	}
	{
		p.SetState(243)
		p.Match(ABSLParserStringLiteral)
	}

	return localctx
}

// IAliasNameContext is an interface to support dynamic dispatch.
type IAliasNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasNameContext differentiates from other interfaces.
	IsAliasNameContext()
}

type AliasNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasNameContext() *AliasNameContext {
	var p = new(AliasNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_aliasName
	return p
}

func (*AliasNameContext) IsAliasNameContext() {}

func NewAliasNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasNameContext {
	var p = new(AliasNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_aliasName

	return p
}

func (s *AliasNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasNameContext) AllIdentifierName() []IIdentifierNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierNameContext)(nil)).Elem())
	var tst = make([]IIdentifierNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierNameContext)
		}
	}

	return tst
}

func (s *AliasNameContext) IdentifierName(i int) IIdentifierNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *AliasNameContext) As() antlr.TerminalNode {
	return s.GetToken(ABSLParserAs, 0)
}

func (s *AliasNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterAliasName(s)
	}
}

func (s *AliasNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitAliasName(s)
	}
}

func (s *AliasNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitAliasName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) AliasName() (localctx IAliasNameContext) {
	localctx = NewAliasNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ABSLParserRULE_aliasName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(245)
		p.IdentifierName()
	}
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserAs {
		{
			p.SetState(246)
			p.Match(ABSLParserAs)
		}
		{
			p.SetState(247)
			p.IdentifierName()
		}

	}

	return localctx
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_exportStatement
	return p
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) CopyFrom(ctx *ExportStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExportDefaultDeclarationContext struct {
	*ExportStatementContext
}

func NewExportDefaultDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportDefaultDeclarationContext {
	var p = new(ExportDefaultDeclarationContext)

	p.ExportStatementContext = NewEmptyExportStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportDefaultDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDefaultDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(ABSLParserExport, 0)
}

func (s *ExportDefaultDeclarationContext) Default() antlr.TerminalNode {
	return s.GetToken(ABSLParserDefault, 0)
}

func (s *ExportDefaultDeclarationContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExportDefaultDeclarationContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportDefaultDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterExportDefaultDeclaration(s)
	}
}

func (s *ExportDefaultDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitExportDefaultDeclaration(s)
	}
}

func (s *ExportDefaultDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitExportDefaultDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExportDeclarationContext struct {
	*ExportStatementContext
}

func NewExportDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportDeclarationContext {
	var p = new(ExportDeclarationContext)

	p.ExportStatementContext = NewEmptyExportStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExportStatementContext))

	return p
}

func (s *ExportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDeclarationContext) Export() antlr.TerminalNode {
	return s.GetToken(ABSLParserExport, 0)
}

func (s *ExportDeclarationContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportDeclarationContext) ExportFromBlock() IExportFromBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportFromBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportFromBlockContext)
}

func (s *ExportDeclarationContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ExportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterExportDeclaration(s)
	}
}

func (s *ExportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitExportDeclaration(s)
	}
}

func (s *ExportDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitExportDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ABSLParserRULE_exportStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExportDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(250)
			p.Match(ABSLParserExport)
		}
		p.SetState(253)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ABSLParserOpenBrace, ABSLParserMultiply:
			{
				p.SetState(251)
				p.ExportFromBlock()
			}

		case ABSLParserVar, ABSLParserFunction, ABSLParserClass, ABSLParserConst, ABSLParserAsync, ABSLParserLet:
			{
				p.SetState(252)
				p.Declaration()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(255)
			p.Eos()
		}

	case 2:
		localctx = NewExportDefaultDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(257)
			p.Match(ABSLParserExport)
		}
		{
			p.SetState(258)
			p.Match(ABSLParserDefault)
		}
		{
			p.SetState(259)
			p.singleExpression(0)
		}
		{
			p.SetState(260)
			p.Eos()
		}

	}

	return localctx
}

// IExportFromBlockContext is an interface to support dynamic dispatch.
type IExportFromBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportFromBlockContext differentiates from other interfaces.
	IsExportFromBlockContext()
}

type ExportFromBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportFromBlockContext() *ExportFromBlockContext {
	var p = new(ExportFromBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_exportFromBlock
	return p
}

func (*ExportFromBlockContext) IsExportFromBlockContext() {}

func NewExportFromBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportFromBlockContext {
	var p = new(ExportFromBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_exportFromBlock

	return p
}

func (s *ExportFromBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportFromBlockContext) ImportNamespace() IImportNamespaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportNamespaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportNamespaceContext)
}

func (s *ExportFromBlockContext) ImportFrom() IImportFromContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportFromContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportFromContext)
}

func (s *ExportFromBlockContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExportFromBlockContext) ModuleItems() IModuleItemsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleItemsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleItemsContext)
}

func (s *ExportFromBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportFromBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportFromBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterExportFromBlock(s)
	}
}

func (s *ExportFromBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitExportFromBlock(s)
	}
}

func (s *ExportFromBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitExportFromBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ExportFromBlock() (localctx IExportFromBlockContext) {
	localctx = NewExportFromBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ABSLParserRULE_exportFromBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(274)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserMultiply:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(264)
			p.ImportNamespace()
		}
		{
			p.SetState(265)
			p.ImportFrom()
		}
		{
			p.SetState(266)
			p.Eos()
		}

	case ABSLParserOpenBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(268)
			p.ModuleItems()
		}
		p.SetState(270)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserFrom {
			{
				p.SetState(269)
				p.ImportFrom()
			}

		}
		{
			p.SetState(272)
			p.Eos()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) VariableStatement() IVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *DeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ABSLParserRULE_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(279)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserVar, ABSLParserConst, ABSLParserLet:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(276)
			p.VariableStatement()
		}

	case ABSLParserClass:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(277)
			p.ClassDeclaration()
		}

	case ABSLParserFunction, ABSLParserAsync:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(278)
			p.FunctionDeclaration()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableStatementContext is an interface to support dynamic dispatch.
type IVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableStatementContext differentiates from other interfaces.
	IsVariableStatementContext()
}

type VariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableStatementContext() *VariableStatementContext {
	var p = new(VariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_variableStatement
	return p
}

func (*VariableStatementContext) IsVariableStatementContext() {}

func NewVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableStatementContext {
	var p = new(VariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_variableStatement

	return p
}

func (s *VariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableStatementContext) VarModifier() IVarModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarModifierContext)
}

func (s *VariableStatementContext) VariableDeclarationList() IVariableDeclarationListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationListContext)
}

func (s *VariableStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *VariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterVariableStatement(s)
	}
}

func (s *VariableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitVariableStatement(s)
	}
}

func (s *VariableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitVariableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) VariableStatement() (localctx IVariableStatementContext) {
	localctx = NewVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ABSLParserRULE_variableStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(281)
		p.VarModifier()
	}
	{
		p.SetState(282)
		p.VariableDeclarationList()
	}
	{
		p.SetState(283)
		p.Eos()
	}

	return localctx
}

// IVariableDeclarationListContext is an interface to support dynamic dispatch.
type IVariableDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationListContext differentiates from other interfaces.
	IsVariableDeclarationListContext()
}

type VariableDeclarationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationListContext() *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_variableDeclarationList
	return p
}

func (*VariableDeclarationListContext) IsVariableDeclarationListContext() {}

func NewVariableDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationListContext {
	var p = new(VariableDeclarationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_variableDeclarationList

	return p
}

func (s *VariableDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationListContext) AllVariableDeclaration() []IVariableDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem())
	var tst = make([]IVariableDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclarationContext)
		}
	}

	return tst
}

func (s *VariableDeclarationListContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableDeclarationListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserComma)
}

func (s *VariableDeclarationListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserComma, i)
}

func (s *VariableDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitVariableDeclarationList(s)
	}
}

func (s *VariableDeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitVariableDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) VariableDeclarationList() (localctx IVariableDeclarationListContext) {
	localctx = NewVariableDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ABSLParserRULE_variableDeclarationList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(285)
		p.VariableDeclaration()
	}
	p.SetState(290)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ABSLParserComma {
		{
			p.SetState(286)
			p.Match(ABSLParserComma)
		}
		{
			p.SetState(287)
			p.VariableDeclaration()
		}

		p.SetState(292)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) Assignable() IAssignableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *VariableDeclarationContext) Colon() antlr.TerminalNode {
	return s.GetToken(ABSLParserColon, 0)
}

func (s *VariableDeclarationContext) VariableType() IVariableTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableTypeContext)
}

func (s *VariableDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(ABSLParserAssign, 0)
}

func (s *VariableDeclarationContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ABSLParserRULE_variableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(293)
		p.Assignable()
	}
	p.SetState(296)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserColon {
		{
			p.SetState(294)
			p.Match(ABSLParserColon)
		}
		{
			p.SetState(295)
			p.VariableType()
		}

	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserAssign {
		{
			p.SetState(298)
			p.Match(ABSLParserAssign)
		}
		{
			p.SetState(299)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IVariableTypeContext is an interface to support dynamic dispatch.
type IVariableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTypeContext differentiates from other interfaces.
	IsVariableTypeContext()
}

type VariableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTypeContext() *VariableTypeContext {
	var p = new(VariableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_variableType
	return p
}

func (*VariableTypeContext) IsVariableTypeContext() {}

func NewVariableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTypeContext {
	var p = new(VariableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_variableType

	return p
}

func (s *VariableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTypeContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VariableTypeContext) CollectionOf() antlr.TerminalNode {
	return s.GetToken(ABSLParserCollectionOf, 0)
}

func (s *VariableTypeContext) ElementOf() antlr.TerminalNode {
	return s.GetToken(ABSLParserElementOf, 0)
}

func (s *VariableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterVariableType(s)
	}
}

func (s *VariableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitVariableType(s)
	}
}

func (s *VariableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitVariableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) VariableType() (localctx IVariableTypeContext) {
	localctx = NewVariableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ABSLParserRULE_variableType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserCollectionOf {
		{
			p.SetState(302)
			p.Match(ABSLParserCollectionOf)
		}

	}
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserElementOf {
		{
			p.SetState(305)
			p.Match(ABSLParserElementOf)
		}

	}
	{
		p.SetState(308)
		p.singleExpression(0)
	}

	return localctx
}

// IEmptyStatementContext is an interface to support dynamic dispatch.
type IEmptyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmptyStatementContext differentiates from other interfaces.
	IsEmptyStatementContext()
}

type EmptyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatementContext() *EmptyStatementContext {
	var p = new(EmptyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_emptyStatement
	return p
}

func (*EmptyStatementContext) IsEmptyStatementContext() {}

func NewEmptyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatementContext {
	var p = new(EmptyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_emptyStatement

	return p
}

func (s *EmptyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatementContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(ABSLParserSemiColon, 0)
}

func (s *EmptyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitEmptyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) EmptyStatement() (localctx IEmptyStatementContext) {
	localctx = NewEmptyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ABSLParserRULE_emptyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(310)
		p.Match(ABSLParserSemiColon)
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ExpressionStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ABSLParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		p.ExpressionSequence()
	}
	{
		p.SetState(313)
		p.Eos()
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(ABSLParserIf, 0)
}

func (s *IfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *IfStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *IfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *IfStatementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *IfStatementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(ABSLParserElse, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ABSLParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(315)
		p.Match(ABSLParserIf)
	}
	{
		p.SetState(316)
		p.Match(ABSLParserOpenParen)
	}
	{
		p.SetState(317)
		p.ExpressionSequence()
	}
	{
		p.SetState(318)
		p.Match(ABSLParserCloseParen)
	}
	{
		p.SetState(319)
		p.Statement()
	}
	p.SetState(322)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(320)
			p.Match(ABSLParserElse)
		}
		{
			p.SetState(321)
			p.Statement()
		}

	}

	return localctx
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_iterationStatement
	return p
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) CopyFrom(ctx *IterationStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoStatementContext struct {
	*IterationStatementContext
}

func NewDoStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoStatementContext {
	var p = new(DoStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(ABSLParserDo, 0)
}

func (s *DoStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoStatementContext) While() antlr.TerminalNode {
	return s.GetToken(ABSLParserWhile, 0)
}

func (s *DoStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *DoStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *DoStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *DoStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (s *DoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitDoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhileStatementContext struct {
	*IterationStatementContext
}

func NewWhileStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(ABSLParserWhile, 0)
}

func (s *WhileStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *WhileStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WhileStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForStatementContext struct {
	*IterationStatementContext
}

func NewForStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStatementContext {
	var p = new(ForStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(ABSLParserFor, 0)
}

func (s *ForStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *ForStatementContext) AllSemiColon() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserSemiColon)
}

func (s *ForStatementContext) SemiColon(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserSemiColon, i)
}

func (s *ForStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) AllExpressionSequence() []IExpressionSequenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem())
	var tst = make([]IExpressionSequenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionSequenceContext)
		}
	}

	return tst
}

func (s *ForStatementContext) ExpressionSequence(i int) IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForStatementContext) VariableStatement() IVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForInStatementContext struct {
	*IterationStatementContext
}

func NewForInStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInStatementContext {
	var p = new(ForInStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInStatementContext) For() antlr.TerminalNode {
	return s.GetToken(ABSLParserFor, 0)
}

func (s *ForInStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *ForInStatementContext) In() antlr.TerminalNode {
	return s.GetToken(ABSLParserIn, 0)
}

func (s *ForInStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForInStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *ForInStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForInStatementContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForInStatementContext) VariableStatement() IVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *ForInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterForInStatement(s)
	}
}

func (s *ForInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitForInStatement(s)
	}
}

func (s *ForInStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitForInStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForeachStatementContext struct {
	*IterationStatementContext
}

func NewForeachStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForeachStatementContext {
	var p = new(ForeachStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForeachStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeachStatementContext) Foreach() antlr.TerminalNode {
	return s.GetToken(ABSLParserForeach, 0)
}

func (s *ForeachStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *ForeachStatementContext) Var() antlr.TerminalNode {
	return s.GetToken(ABSLParserVar, 0)
}

func (s *ForeachStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *ForeachStatementContext) In() antlr.TerminalNode {
	return s.GetToken(ABSLParserIn, 0)
}

func (s *ForeachStatementContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForeachStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *ForeachStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForeachStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterForeachStatement(s)
	}
}

func (s *ForeachStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitForeachStatement(s)
	}
}

func (s *ForeachStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitForeachStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForOfStatementContext struct {
	*IterationStatementContext
}

func NewForOfStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForOfStatementContext {
	var p = new(ForOfStatementContext)

	p.IterationStatementContext = NewEmptyIterationStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IterationStatementContext))

	return p
}

func (s *ForOfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForOfStatementContext) For() antlr.TerminalNode {
	return s.GetToken(ABSLParserFor, 0)
}

func (s *ForOfStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *ForOfStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *ForOfStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ForOfStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *ForOfStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForOfStatementContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ForOfStatementContext) VariableStatement() IVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableStatementContext)
}

func (s *ForOfStatementContext) Await() antlr.TerminalNode {
	return s.GetToken(ABSLParserAwait, 0)
}

func (s *ForOfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterForOfStatement(s)
	}
}

func (s *ForOfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitForOfStatement(s)
	}
}

func (s *ForOfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitForOfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) IterationStatement() (localctx IIterationStatementContext) {
	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ABSLParserRULE_iterationStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDoStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(324)
			p.Match(ABSLParserDo)
		}
		{
			p.SetState(325)
			p.Statement()
		}
		{
			p.SetState(326)
			p.Match(ABSLParserWhile)
		}
		{
			p.SetState(327)
			p.Match(ABSLParserOpenParen)
		}
		{
			p.SetState(328)
			p.ExpressionSequence()
		}
		{
			p.SetState(329)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(330)
			p.Eos()
		}

	case 2:
		localctx = NewWhileStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(332)
			p.Match(ABSLParserWhile)
		}
		{
			p.SetState(333)
			p.Match(ABSLParserOpenParen)
		}
		{
			p.SetState(334)
			p.ExpressionSequence()
		}
		{
			p.SetState(335)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(336)
			p.Statement()
		}

	case 3:
		localctx = NewForStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(338)
			p.Match(ABSLParserFor)
		}
		{
			p.SetState(339)
			p.Match(ABSLParserOpenParen)
		}
		p.SetState(342)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ABSLParserRegularExpressionLiteral, ABSLParserOpenBracket, ABSLParserOpenParen, ABSLParserOpenBrace, ABSLParserPlusPlus, ABSLParserMinusMinus, ABSLParserPlus, ABSLParserMinus, ABSLParserBitNot, ABSLParserNot, ABSLParserNullLiteral, ABSLParserBooleanLiteral, ABSLParserDecimalLiteral, ABSLParserHexIntegerLiteral, ABSLParserOctalIntegerLiteral, ABSLParserOctalIntegerLiteral2, ABSLParserBinaryIntegerLiteral, ABSLParserBigHexIntegerLiteral, ABSLParserBigOctalIntegerLiteral, ABSLParserBigBinaryIntegerLiteral, ABSLParserBigDecimalIntegerLiteral, ABSLParserTypeof, ABSLParserNew, ABSLParserVoid, ABSLParserFunction, ABSLParserThis, ABSLParserDelete, ABSLParserClass, ABSLParserSuper, ABSLParserImport, ABSLParserAsync, ABSLParserAwait, ABSLParserYield, ABSLParserIdentifier, ABSLParserStringLiteral, ABSLParserTemplateStringLiteral:
			{
				p.SetState(340)
				p.ExpressionSequence()
			}

		case ABSLParserVar, ABSLParserConst, ABSLParserLet:
			{
				p.SetState(341)
				p.VariableStatement()
			}

		case ABSLParserSemiColon:

		default:
		}
		{
			p.SetState(344)
			p.Match(ABSLParserSemiColon)
		}
		p.SetState(346)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
			{
				p.SetState(345)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(348)
			p.Match(ABSLParserSemiColon)
		}
		p.SetState(350)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
			{
				p.SetState(349)
				p.ExpressionSequence()
			}

		}
		{
			p.SetState(352)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(353)
			p.Statement()
		}

	case 4:
		localctx = NewForInStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(354)
			p.Match(ABSLParserFor)
		}
		{
			p.SetState(355)
			p.Match(ABSLParserOpenParen)
		}
		p.SetState(358)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ABSLParserRegularExpressionLiteral, ABSLParserOpenBracket, ABSLParserOpenParen, ABSLParserOpenBrace, ABSLParserPlusPlus, ABSLParserMinusMinus, ABSLParserPlus, ABSLParserMinus, ABSLParserBitNot, ABSLParserNot, ABSLParserNullLiteral, ABSLParserBooleanLiteral, ABSLParserDecimalLiteral, ABSLParserHexIntegerLiteral, ABSLParserOctalIntegerLiteral, ABSLParserOctalIntegerLiteral2, ABSLParserBinaryIntegerLiteral, ABSLParserBigHexIntegerLiteral, ABSLParserBigOctalIntegerLiteral, ABSLParserBigBinaryIntegerLiteral, ABSLParserBigDecimalIntegerLiteral, ABSLParserTypeof, ABSLParserNew, ABSLParserVoid, ABSLParserFunction, ABSLParserThis, ABSLParserDelete, ABSLParserClass, ABSLParserSuper, ABSLParserImport, ABSLParserAsync, ABSLParserAwait, ABSLParserYield, ABSLParserIdentifier, ABSLParserStringLiteral, ABSLParserTemplateStringLiteral:
			{
				p.SetState(356)
				p.singleExpression(0)
			}

		case ABSLParserVar, ABSLParserConst, ABSLParserLet:
			{
				p.SetState(357)
				p.VariableStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(360)
			p.Match(ABSLParserIn)
		}
		{
			p.SetState(361)
			p.ExpressionSequence()
		}
		{
			p.SetState(362)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(363)
			p.Statement()
		}

	case 5:
		localctx = NewForOfStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(365)
			p.Match(ABSLParserFor)
		}
		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserAwait {
			{
				p.SetState(366)
				p.Match(ABSLParserAwait)
			}

		}
		{
			p.SetState(369)
			p.Match(ABSLParserOpenParen)
		}
		p.SetState(372)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ABSLParserRegularExpressionLiteral, ABSLParserOpenBracket, ABSLParserOpenParen, ABSLParserOpenBrace, ABSLParserPlusPlus, ABSLParserMinusMinus, ABSLParserPlus, ABSLParserMinus, ABSLParserBitNot, ABSLParserNot, ABSLParserNullLiteral, ABSLParserBooleanLiteral, ABSLParserDecimalLiteral, ABSLParserHexIntegerLiteral, ABSLParserOctalIntegerLiteral, ABSLParserOctalIntegerLiteral2, ABSLParserBinaryIntegerLiteral, ABSLParserBigHexIntegerLiteral, ABSLParserBigOctalIntegerLiteral, ABSLParserBigBinaryIntegerLiteral, ABSLParserBigDecimalIntegerLiteral, ABSLParserTypeof, ABSLParserNew, ABSLParserVoid, ABSLParserFunction, ABSLParserThis, ABSLParserDelete, ABSLParserClass, ABSLParserSuper, ABSLParserImport, ABSLParserAsync, ABSLParserAwait, ABSLParserYield, ABSLParserIdentifier, ABSLParserStringLiteral, ABSLParserTemplateStringLiteral:
			{
				p.SetState(370)
				p.singleExpression(0)
			}

		case ABSLParserVar, ABSLParserConst, ABSLParserLet:
			{
				p.SetState(371)
				p.VariableStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(374)
			p.Match(ABSLParserIdentifier)
		}
		{
			p.SetState(375)
			p.ExpressionSequence()
		}
		{
			p.SetState(376)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(377)
			p.Statement()
		}

	case 6:
		localctx = NewForeachStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(379)
			p.Match(ABSLParserForeach)
		}
		{
			p.SetState(380)
			p.Match(ABSLParserOpenParen)
		}
		{
			p.SetState(381)
			p.Match(ABSLParserVar)
		}
		{
			p.SetState(382)
			p.Match(ABSLParserIdentifier)
		}
		{
			p.SetState(383)
			p.Match(ABSLParserIn)
		}
		{
			p.SetState(384)
			p.singleExpression(0)
		}
		{
			p.SetState(385)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(386)
			p.Statement()
		}

	}

	return localctx
}

// IVarModifierContext is an interface to support dynamic dispatch.
type IVarModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarModifierContext differentiates from other interfaces.
	IsVarModifierContext()
}

type VarModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarModifierContext() *VarModifierContext {
	var p = new(VarModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_varModifier
	return p
}

func (*VarModifierContext) IsVarModifierContext() {}

func NewVarModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarModifierContext {
	var p = new(VarModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_varModifier

	return p
}

func (s *VarModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarModifierContext) Var() antlr.TerminalNode {
	return s.GetToken(ABSLParserVar, 0)
}

func (s *VarModifierContext) Let() antlr.TerminalNode {
	return s.GetToken(ABSLParserLet, 0)
}

func (s *VarModifierContext) Const() antlr.TerminalNode {
	return s.GetToken(ABSLParserConst, 0)
}

func (s *VarModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterVarModifier(s)
	}
}

func (s *VarModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitVarModifier(s)
	}
}

func (s *VarModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitVarModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) VarModifier() (localctx IVarModifierContext) {
	localctx = NewVarModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ABSLParserRULE_varModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(390)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ABSLParserVar || _la == ABSLParserConst || _la == ABSLParserLet) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(ABSLParserContinue, 0)
}

func (s *ContinueStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ContinueStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ABSLParserRULE_continueStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Match(ABSLParserContinue)
	}
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserIdentifier {
		{
			p.SetState(393)
			p.Match(ABSLParserIdentifier)
		}

	}
	{
		p.SetState(396)
		p.Eos()
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(ABSLParserBreak, 0)
}

func (s *BreakStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *BreakStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ABSLParserRULE_breakStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(398)
		p.Match(ABSLParserBreak)
	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserIdentifier {
		{
			p.SetState(399)
			p.Match(ABSLParserIdentifier)
		}

	}
	{
		p.SetState(402)
		p.Eos()
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(ABSLParserReturn, 0)
}

func (s *ReturnStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ReturnStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ABSLParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.Match(ABSLParserReturn)
	}
	p.SetState(406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(405)
			p.ExpressionSequence()
		}

	}
	{
		p.SetState(408)
		p.Eos()
	}

	return localctx
}

// IYieldStatementContext is an interface to support dynamic dispatch.
type IYieldStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldStatementContext differentiates from other interfaces.
	IsYieldStatementContext()
}

type YieldStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStatementContext() *YieldStatementContext {
	var p = new(YieldStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_yieldStatement
	return p
}

func (*YieldStatementContext) IsYieldStatementContext() {}

func NewYieldStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStatementContext {
	var p = new(YieldStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_yieldStatement

	return p
}

func (s *YieldStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStatementContext) Yield() antlr.TerminalNode {
	return s.GetToken(ABSLParserYield, 0)
}

func (s *YieldStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *YieldStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *YieldStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterYieldStatement(s)
	}
}

func (s *YieldStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitYieldStatement(s)
	}
}

func (s *YieldStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitYieldStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) YieldStatement() (localctx IYieldStatementContext) {
	localctx = NewYieldStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ABSLParserRULE_yieldStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(410)
		p.Match(ABSLParserYield)
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(411)
			p.ExpressionSequence()
		}

	}
	{
		p.SetState(414)
		p.Eos()
	}

	return localctx
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_withStatement
	return p
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) With() antlr.TerminalNode {
	return s.GetToken(ABSLParserWith, 0)
}

func (s *WithStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *WithStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *WithStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *WithStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (s *WithStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitWithStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) WithStatement() (localctx IWithStatementContext) {
	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ABSLParserRULE_withStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Match(ABSLParserWith)
	}
	{
		p.SetState(417)
		p.Match(ABSLParserOpenParen)
	}
	{
		p.SetState(418)
		p.ExpressionSequence()
	}
	{
		p.SetState(419)
		p.Match(ABSLParserCloseParen)
	}
	{
		p.SetState(420)
		p.Statement()
	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(ABSLParserSwitch, 0)
}

func (s *SwitchStatementContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *SwitchStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *SwitchStatementContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *SwitchStatementContext) CaseBlock() ICaseBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ABSLParserRULE_switchStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.Match(ABSLParserSwitch)
	}
	{
		p.SetState(423)
		p.Match(ABSLParserOpenParen)
	}
	{
		p.SetState(424)
		p.ExpressionSequence()
	}
	{
		p.SetState(425)
		p.Match(ABSLParserCloseParen)
	}
	{
		p.SetState(426)
		p.CaseBlock()
	}

	return localctx
}

// ICaseBlockContext is an interface to support dynamic dispatch.
type ICaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseBlockContext differentiates from other interfaces.
	IsCaseBlockContext()
}

type CaseBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseBlockContext() *CaseBlockContext {
	var p = new(CaseBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_caseBlock
	return p
}

func (*CaseBlockContext) IsCaseBlockContext() {}

func NewCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseBlockContext {
	var p = new(CaseBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_caseBlock

	return p
}

func (s *CaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseBlockContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *CaseBlockContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *CaseBlockContext) AllCaseClauses() []ICaseClausesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseClausesContext)(nil)).Elem())
	var tst = make([]ICaseClausesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseClausesContext)
		}
	}

	return tst
}

func (s *CaseBlockContext) CaseClauses(i int) ICaseClausesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseClausesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseClausesContext)
}

func (s *CaseBlockContext) DefaultClause() IDefaultClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *CaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterCaseBlock(s)
	}
}

func (s *CaseBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitCaseBlock(s)
	}
}

func (s *CaseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitCaseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) CaseBlock() (localctx ICaseBlockContext) {
	localctx = NewCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ABSLParserRULE_caseBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(428)
		p.Match(ABSLParserOpenBrace)
	}
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserCase {
		{
			p.SetState(429)
			p.CaseClauses()
		}

	}
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserDefault {
		{
			p.SetState(432)
			p.DefaultClause()
		}
		p.SetState(434)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserCase {
			{
				p.SetState(433)
				p.CaseClauses()
			}

		}

	}
	{
		p.SetState(438)
		p.Match(ABSLParserCloseBrace)
	}

	return localctx
}

// ICaseClausesContext is an interface to support dynamic dispatch.
type ICaseClausesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClausesContext differentiates from other interfaces.
	IsCaseClausesContext()
}

type CaseClausesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClausesContext() *CaseClausesContext {
	var p = new(CaseClausesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_caseClauses
	return p
}

func (*CaseClausesContext) IsCaseClausesContext() {}

func NewCaseClausesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClausesContext {
	var p = new(CaseClausesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_caseClauses

	return p
}

func (s *CaseClausesContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClausesContext) AllCaseClause() []ICaseClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseClauseContext)(nil)).Elem())
	var tst = make([]ICaseClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseClauseContext)
		}
	}

	return tst
}

func (s *CaseClausesContext) CaseClause(i int) ICaseClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *CaseClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClausesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClausesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterCaseClauses(s)
	}
}

func (s *CaseClausesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitCaseClauses(s)
	}
}

func (s *CaseClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitCaseClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) CaseClauses() (localctx ICaseClausesContext) {
	localctx = NewCaseClausesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ABSLParserRULE_caseClauses)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ABSLParserCase {
		{
			p.SetState(440)
			p.CaseClause()
		}

		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_caseClause
	return p
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) Case() antlr.TerminalNode {
	return s.GetToken(ABSLParserCase, 0)
}

func (s *CaseClauseContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *CaseClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(ABSLParserColon, 0)
}

func (s *CaseClauseContext) StatementList() IStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *CaseClauseContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *CaseClauseContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *CaseClauseContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ABSLParserRULE_caseClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(445)
			p.Match(ABSLParserCase)
		}
		{
			p.SetState(446)
			p.ExpressionSequence()
		}
		{
			p.SetState(447)
			p.Match(ABSLParserColon)
		}
		p.SetState(449)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserSemiColon)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserForeach-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserRaise-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
			{
				p.SetState(448)
				p.StatementList()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(451)
			p.Match(ABSLParserCase)
		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(452)
				p.Match(ABSLParserOpenParen)
			}

		}
		{
			p.SetState(455)
			p.singleExpression(0)
		}
		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserCloseParen {
			{
				p.SetState(456)
				p.Match(ABSLParserCloseParen)
			}

		}
		p.SetState(460)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserSemiColon)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserForeach-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserRaise-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
			{
				p.SetState(459)
				p.StatementList()
			}

		}

	}

	return localctx
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_defaultClause
	return p
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) Default() antlr.TerminalNode {
	return s.GetToken(ABSLParserDefault, 0)
}

func (s *DefaultClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(ABSLParserColon, 0)
}

func (s *DefaultClauseContext) StatementList() IStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementListContext)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ABSLParserRULE_defaultClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Match(ABSLParserDefault)
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserColon {
		{
			p.SetState(465)
			p.Match(ABSLParserColon)
		}

	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserSemiColon)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserForeach-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserRaise-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(468)
			p.StatementList()
		}

	}

	return localctx
}

// ILabelledStatementContext is an interface to support dynamic dispatch.
type ILabelledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelledStatementContext differentiates from other interfaces.
	IsLabelledStatementContext()
}

type LabelledStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelledStatementContext() *LabelledStatementContext {
	var p = new(LabelledStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_labelledStatement
	return p
}

func (*LabelledStatementContext) IsLabelledStatementContext() {}

func NewLabelledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelledStatementContext {
	var p = new(LabelledStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_labelledStatement

	return p
}

func (s *LabelledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelledStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *LabelledStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(ABSLParserColon, 0)
}

func (s *LabelledStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabelledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterLabelledStatement(s)
	}
}

func (s *LabelledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitLabelledStatement(s)
	}
}

func (s *LabelledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitLabelledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) LabelledStatement() (localctx ILabelledStatementContext) {
	localctx = NewLabelledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ABSLParserRULE_labelledStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.Match(ABSLParserIdentifier)
	}
	{
		p.SetState(472)
		p.Match(ABSLParserColon)
	}
	{
		p.SetState(473)
		p.Statement()
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(ABSLParserThrow, 0)
}

func (s *ThrowStatementContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ThrowStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *ThrowStatementContext) Raise() antlr.TerminalNode {
	return s.GetToken(ABSLParserRaise, 0)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (s *ThrowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitThrowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ABSLParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(483)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserThrow:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(475)
			p.Match(ABSLParserThrow)
		}
		{
			p.SetState(476)
			p.ExpressionSequence()
		}
		{
			p.SetState(477)
			p.Eos()
		}

	case ABSLParserRaise:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(479)
			p.Match(ABSLParserRaise)
		}
		{
			p.SetState(480)
			p.ExpressionSequence()
		}
		{
			p.SetState(481)
			p.Eos()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_tryStatement
	return p
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) Try() antlr.TerminalNode {
	return s.GetToken(ABSLParserTry, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) CatchProduction() ICatchProductionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchProductionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatchProductionContext)
}

func (s *TryStatementContext) FinallyProduction() IFinallyProductionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinallyProductionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinallyProductionContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (s *TryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitTryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ABSLParserRULE_tryStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(ABSLParserTry)
	}
	{
		p.SetState(486)
		p.Block()
	}
	p.SetState(492)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserCatch:
		{
			p.SetState(487)
			p.CatchProduction()
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserFinally {
			{
				p.SetState(488)
				p.FinallyProduction()
			}

		}

	case ABSLParserFinally:
		{
			p.SetState(491)
			p.FinallyProduction()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICatchProductionContext is an interface to support dynamic dispatch.
type ICatchProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchProductionContext differentiates from other interfaces.
	IsCatchProductionContext()
}

type CatchProductionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchProductionContext() *CatchProductionContext {
	var p = new(CatchProductionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_catchProduction
	return p
}

func (*CatchProductionContext) IsCatchProductionContext() {}

func NewCatchProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchProductionContext {
	var p = new(CatchProductionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_catchProduction

	return p
}

func (s *CatchProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchProductionContext) Catch() antlr.TerminalNode {
	return s.GetToken(ABSLParserCatch, 0)
}

func (s *CatchProductionContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchProductionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *CatchProductionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *CatchProductionContext) Assignable() IAssignableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *CatchProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterCatchProduction(s)
	}
}

func (s *CatchProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitCatchProduction(s)
	}
}

func (s *CatchProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitCatchProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) CatchProduction() (localctx ICatchProductionContext) {
	localctx = NewCatchProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ABSLParserRULE_catchProduction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(494)
		p.Match(ABSLParserCatch)
	}
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserOpenParen {
		{
			p.SetState(495)
			p.Match(ABSLParserOpenParen)
		}
		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserOpenBracket || _la == ABSLParserOpenBrace || _la == ABSLParserIdentifier {
			{
				p.SetState(496)
				p.Assignable()
			}

		}
		{
			p.SetState(499)
			p.Match(ABSLParserCloseParen)
		}

	}
	{
		p.SetState(502)
		p.Block()
	}

	return localctx
}

// IFinallyProductionContext is an interface to support dynamic dispatch.
type IFinallyProductionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyProductionContext differentiates from other interfaces.
	IsFinallyProductionContext()
}

type FinallyProductionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyProductionContext() *FinallyProductionContext {
	var p = new(FinallyProductionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_finallyProduction
	return p
}

func (*FinallyProductionContext) IsFinallyProductionContext() {}

func NewFinallyProductionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyProductionContext {
	var p = new(FinallyProductionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_finallyProduction

	return p
}

func (s *FinallyProductionContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyProductionContext) Finally() antlr.TerminalNode {
	return s.GetToken(ABSLParserFinally, 0)
}

func (s *FinallyProductionContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyProductionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyProductionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyProductionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitFinallyProduction(s)
	}
}

func (s *FinallyProductionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitFinallyProduction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) FinallyProduction() (localctx IFinallyProductionContext) {
	localctx = NewFinallyProductionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ABSLParserRULE_finallyProduction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(504)
		p.Match(ABSLParserFinally)
	}
	{
		p.SetState(505)
		p.Block()
	}

	return localctx
}

// IDebuggerStatementContext is an interface to support dynamic dispatch.
type IDebuggerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDebuggerStatementContext differentiates from other interfaces.
	IsDebuggerStatementContext()
}

type DebuggerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDebuggerStatementContext() *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_debuggerStatement
	return p
}

func (*DebuggerStatementContext) IsDebuggerStatementContext() {}

func NewDebuggerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DebuggerStatementContext {
	var p = new(DebuggerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_debuggerStatement

	return p
}

func (s *DebuggerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DebuggerStatementContext) Debugger() antlr.TerminalNode {
	return s.GetToken(ABSLParserDebugger, 0)
}

func (s *DebuggerStatementContext) Eos() IEosContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEosContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEosContext)
}

func (s *DebuggerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DebuggerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DebuggerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterDebuggerStatement(s)
	}
}

func (s *DebuggerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitDebuggerStatement(s)
	}
}

func (s *DebuggerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitDebuggerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) DebuggerStatement() (localctx IDebuggerStatementContext) {
	localctx = NewDebuggerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ABSLParserRULE_debuggerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(507)
		p.Match(ABSLParserDebugger)
	}
	{
		p.SetState(508)
		p.Eos()
	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Function() antlr.TerminalNode {
	return s.GetToken(ABSLParserFunction, 0)
}

func (s *FunctionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *FunctionDeclarationContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *FunctionDeclarationContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *FunctionDeclarationContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *FunctionDeclarationContext) Async() antlr.TerminalNode {
	return s.GetToken(ABSLParserAsync, 0)
}

func (s *FunctionDeclarationContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ABSLParserMultiply, 0)
}

func (s *FunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ABSLParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserAsync {
		{
			p.SetState(510)
			p.Match(ABSLParserAsync)
		}

	}
	{
		p.SetState(513)
		p.Match(ABSLParserFunction)
	}
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserMultiply {
		{
			p.SetState(514)
			p.Match(ABSLParserMultiply)
		}

	}
	{
		p.SetState(517)
		p.Match(ABSLParserIdentifier)
	}
	{
		p.SetState(518)
		p.Match(ABSLParserOpenParen)
	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserEllipsis))) != 0) || _la == ABSLParserIdentifier {
		{
			p.SetState(519)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(522)
		p.Match(ABSLParserCloseParen)
	}
	{
		p.SetState(523)
		p.Match(ABSLParserOpenBrace)
	}
	{
		p.SetState(524)
		p.FunctionBody()
	}
	{
		p.SetState(525)
		p.Match(ABSLParserCloseBrace)
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) Class() antlr.TerminalNode {
	return s.GetToken(ABSLParserClass, 0)
}

func (s *ClassDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *ClassDeclarationContext) ClassTail() IClassTailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ABSLParserRULE_classDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(527)
		p.Match(ABSLParserClass)
	}
	{
		p.SetState(528)
		p.Match(ABSLParserIdentifier)
	}
	{
		p.SetState(529)
		p.ClassTail()
	}

	return localctx
}

// IClassTailContext is an interface to support dynamic dispatch.
type IClassTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTailContext differentiates from other interfaces.
	IsClassTailContext()
}

type ClassTailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTailContext() *ClassTailContext {
	var p = new(ClassTailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_classTail
	return p
}

func (*ClassTailContext) IsClassTailContext() {}

func NewClassTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTailContext {
	var p = new(ClassTailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_classTail

	return p
}

func (s *ClassTailContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTailContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *ClassTailContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *ClassTailContext) Extends() antlr.TerminalNode {
	return s.GetToken(ABSLParserExtends, 0)
}

func (s *ClassTailContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ClassTailContext) AllClassElement() []IClassElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassElementContext)(nil)).Elem())
	var tst = make([]IClassElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassElementContext)
		}
	}

	return tst
}

func (s *ClassTailContext) ClassElement(i int) IClassElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassElementContext)
}

func (s *ClassTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterClassTail(s)
	}
}

func (s *ClassTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitClassTail(s)
	}
}

func (s *ClassTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitClassTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ClassTail() (localctx IClassTailContext) {
	localctx = NewClassTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ABSLParserRULE_classTail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(533)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserExtends {
		{
			p.SetState(531)
			p.Match(ABSLParserExtends)
		}
		{
			p.SetState(532)
			p.singleExpression(0)
		}

	}
	{
		p.SetState(535)
		p.Match(ABSLParserOpenBrace)
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserOpenBracket)|(1<<ABSLParserSemiColon)|(1<<ABSLParserMultiply)|(1<<ABSLParserHashtag))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserInstanceof-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserCase-59))|(1<<(ABSLParserElse-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserCatch-59))|(1<<(ABSLParserFinally-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserDefault-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserIn-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserAs-91))|(1<<(ABSLParserFrom-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserEnum-91))|(1<<(ABSLParserExtends-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserImplements-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserPrivate-91))|(1<<(ABSLParserPublic-91))|(1<<(ABSLParserInterface-91))|(1<<(ABSLParserPackage-91))|(1<<(ABSLParserProtected-91))|(1<<(ABSLParserStatic-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91)))) != 0) {
		{
			p.SetState(536)
			p.ClassElement()
		}

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(542)
		p.Match(ABSLParserCloseBrace)
	}

	return localctx
}

// IClassElementContext is an interface to support dynamic dispatch.
type IClassElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassElementContext differentiates from other interfaces.
	IsClassElementContext()
}

type ClassElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassElementContext() *ClassElementContext {
	var p = new(ClassElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_classElement
	return p
}

func (*ClassElementContext) IsClassElementContext() {}

func NewClassElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassElementContext {
	var p = new(ClassElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_classElement

	return p
}

func (s *ClassElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassElementContext) MethodDefinition() IMethodDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDefinitionContext)
}

func (s *ClassElementContext) AllStatic() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserStatic)
}

func (s *ClassElementContext) Static(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserStatic, i)
}

func (s *ClassElementContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserIdentifier)
}

func (s *ClassElementContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, i)
}

func (s *ClassElementContext) AllAsync() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserAsync)
}

func (s *ClassElementContext) Async(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserAsync, i)
}

func (s *ClassElementContext) EmptyStatement() IEmptyStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmptyStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmptyStatementContext)
}

func (s *ClassElementContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *ClassElementContext) Assign() antlr.TerminalNode {
	return s.GetToken(ABSLParserAssign, 0)
}

func (s *ClassElementContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ClassElementContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(ABSLParserHashtag, 0)
}

func (s *ClassElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterClassElement(s)
	}
}

func (s *ClassElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitClassElement(s)
	}
}

func (s *ClassElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitClassElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ClassElement() (localctx IClassElementContext) {
	localctx = NewClassElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ABSLParserRULE_classElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(544)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-109)&-(0x1f+1)) == 0 && ((1<<uint((_la-109)))&((1<<(ABSLParserAsync-109))|(1<<(ABSLParserStatic-109))|(1<<(ABSLParserIdentifier-109)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(549)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext())
		}
		{
			p.SetState(550)
			p.MethodDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(551)
			p.EmptyStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserHashtag {
			{
				p.SetState(552)
				p.Match(ABSLParserHashtag)
			}

		}
		{
			p.SetState(555)
			p.PropertyName()
		}
		{
			p.SetState(556)
			p.Match(ABSLParserAssign)
		}
		{
			p.SetState(557)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IMethodDefinitionContext is an interface to support dynamic dispatch.
type IMethodDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodDefinitionContext differentiates from other interfaces.
	IsMethodDefinitionContext()
}

type MethodDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDefinitionContext() *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_methodDefinition
	return p
}

func (*MethodDefinitionContext) IsMethodDefinitionContext() {}

func NewMethodDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDefinitionContext {
	var p = new(MethodDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_methodDefinition

	return p
}

func (s *MethodDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDefinitionContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *MethodDefinitionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *MethodDefinitionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *MethodDefinitionContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *MethodDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *MethodDefinitionContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *MethodDefinitionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ABSLParserMultiply, 0)
}

func (s *MethodDefinitionContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(ABSLParserHashtag, 0)
}

func (s *MethodDefinitionContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *MethodDefinitionContext) Getter() IGetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *MethodDefinitionContext) Setter() ISetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *MethodDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterMethodDefinition(s)
	}
}

func (s *MethodDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitMethodDefinition(s)
	}
}

func (s *MethodDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitMethodDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) MethodDefinition() (localctx IMethodDefinitionContext) {
	localctx = NewMethodDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ABSLParserRULE_methodDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserMultiply {
			{
				p.SetState(561)
				p.Match(ABSLParserMultiply)
			}

		}
		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserHashtag {
			{
				p.SetState(564)
				p.Match(ABSLParserHashtag)
			}

		}
		{
			p.SetState(567)
			p.PropertyName()
		}
		{
			p.SetState(568)
			p.Match(ABSLParserOpenParen)
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserEllipsis))) != 0) || _la == ABSLParserIdentifier {
			{
				p.SetState(569)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(572)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(573)
			p.Match(ABSLParserOpenBrace)
		}
		{
			p.SetState(574)
			p.FunctionBody()
		}
		{
			p.SetState(575)
			p.Match(ABSLParserCloseBrace)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserMultiply {
			{
				p.SetState(577)
				p.Match(ABSLParserMultiply)
			}

		}
		p.SetState(581)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserHashtag {
			{
				p.SetState(580)
				p.Match(ABSLParserHashtag)
			}

		}
		{
			p.SetState(583)
			p.Getter()
		}
		{
			p.SetState(584)
			p.Match(ABSLParserOpenParen)
		}
		{
			p.SetState(585)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(586)
			p.Match(ABSLParserOpenBrace)
		}
		{
			p.SetState(587)
			p.FunctionBody()
		}
		{
			p.SetState(588)
			p.Match(ABSLParserCloseBrace)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserMultiply {
			{
				p.SetState(590)
				p.Match(ABSLParserMultiply)
			}

		}
		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserHashtag {
			{
				p.SetState(593)
				p.Match(ABSLParserHashtag)
			}

		}
		{
			p.SetState(596)
			p.Setter()
		}
		{
			p.SetState(597)
			p.Match(ABSLParserOpenParen)
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserEllipsis))) != 0) || _la == ABSLParserIdentifier {
			{
				p.SetState(598)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(601)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(602)
			p.Match(ABSLParserOpenBrace)
		}
		{
			p.SetState(603)
			p.FunctionBody()
		}
		{
			p.SetState(604)
			p.Match(ABSLParserCloseBrace)
		}

	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameterArg() []IFormalParameterArgContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFormalParameterArgContext)(nil)).Elem())
	var tst = make([]IFormalParameterArgContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFormalParameterArgContext)
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameterArg(i int) IFormalParameterArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterArgContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *FormalParameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserComma)
}

func (s *FormalParameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserComma, i)
}

func (s *FormalParameterListContext) LastFormalParameterArg() ILastFormalParameterArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILastFormalParameterArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterArgContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ABSLParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(621)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserOpenBracket, ABSLParserOpenBrace, ABSLParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(608)
			p.FormalParameterArg()
		}
		p.SetState(613)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(609)
					p.Match(ABSLParserComma)
				}
				{
					p.SetState(610)
					p.FormalParameterArg()
				}

			}
			p.SetState(615)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext())
		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserComma {
			{
				p.SetState(616)
				p.Match(ABSLParserComma)
			}
			{
				p.SetState(617)
				p.LastFormalParameterArg()
			}

		}

	case ABSLParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(620)
			p.LastFormalParameterArg()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFormalParameterArgContext is an interface to support dynamic dispatch.
type IFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterArgContext differentiates from other interfaces.
	IsFormalParameterArgContext()
}

type FormalParameterArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterArgContext() *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_formalParameterArg
	return p
}

func (*FormalParameterArgContext) IsFormalParameterArgContext() {}

func NewFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterArgContext {
	var p = new(FormalParameterArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_formalParameterArg

	return p
}

func (s *FormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterArgContext) Assignable() IAssignableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignableContext)
}

func (s *FormalParameterArgContext) Assign() antlr.TerminalNode {
	return s.GetToken(ABSLParserAssign, 0)
}

func (s *FormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *FormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitFormalParameterArg(s)
	}
}

func (s *FormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) FormalParameterArg() (localctx IFormalParameterArgContext) {
	localctx = NewFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ABSLParserRULE_formalParameterArg)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.Assignable()
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserAssign {
		{
			p.SetState(624)
			p.Match(ABSLParserAssign)
		}
		{
			p.SetState(625)
			p.singleExpression(0)
		}

	}

	return localctx
}

// ILastFormalParameterArgContext is an interface to support dynamic dispatch.
type ILastFormalParameterArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastFormalParameterArgContext differentiates from other interfaces.
	IsLastFormalParameterArgContext()
}

type LastFormalParameterArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterArgContext() *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_lastFormalParameterArg
	return p
}

func (*LastFormalParameterArgContext) IsLastFormalParameterArgContext() {}

func NewLastFormalParameterArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterArgContext {
	var p = new(LastFormalParameterArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_lastFormalParameterArg

	return p
}

func (s *LastFormalParameterArgContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterArgContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(ABSLParserEllipsis, 0)
}

func (s *LastFormalParameterArgContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LastFormalParameterArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitLastFormalParameterArg(s)
	}
}

func (s *LastFormalParameterArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitLastFormalParameterArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) LastFormalParameterArg() (localctx ILastFormalParameterArgContext) {
	localctx = NewLastFormalParameterArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ABSLParserRULE_lastFormalParameterArg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Match(ABSLParserEllipsis)
	}
	{
		p.SetState(629)
		p.singleExpression(0)
	}

	return localctx
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_functionBody
	return p
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) SourceElements() ISourceElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceElementsContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ABSLParserRULE_functionBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserSemiColon)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserForeach-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserRaise-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(631)
			p.SourceElements()
		}

	}

	return localctx
}

// ISourceElementsContext is an interface to support dynamic dispatch.
type ISourceElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceElementsContext differentiates from other interfaces.
	IsSourceElementsContext()
}

type SourceElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceElementsContext() *SourceElementsContext {
	var p = new(SourceElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_sourceElements
	return p
}

func (*SourceElementsContext) IsSourceElementsContext() {}

func NewSourceElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceElementsContext {
	var p = new(SourceElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_sourceElements

	return p
}

func (s *SourceElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceElementsContext) AllSourceElement() []ISourceElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISourceElementContext)(nil)).Elem())
	var tst = make([]ISourceElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISourceElementContext)
		}
	}

	return tst
}

func (s *SourceElementsContext) SourceElement(i int) ISourceElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISourceElementContext)
}

func (s *SourceElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterSourceElements(s)
	}
}

func (s *SourceElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitSourceElements(s)
	}
}

func (s *SourceElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitSourceElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) SourceElements() (localctx ISourceElementsContext) {
	localctx = NewSourceElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ABSLParserRULE_sourceElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserSemiColon)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserForeach-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserRaise-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(634)
			p.SourceElement()
		}

		p.SetState(637)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_arrayLiteral
	return p
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBracket, 0)
}

func (s *ArrayLiteralContext) ElementList() IElementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementListContext)
}

func (s *ArrayLiteralContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBracket, 0)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ABSLParserRULE_arrayLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Match(ABSLParserOpenBracket)
	}
	{
		p.SetState(640)
		p.ElementList()
	}
	{
		p.SetState(641)
		p.Match(ABSLParserCloseBracket)
	}

	return localctx
}

// IElementListContext is an interface to support dynamic dispatch.
type IElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementListContext differentiates from other interfaces.
	IsElementListContext()
}

type ElementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementListContext() *ElementListContext {
	var p = new(ElementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_elementList
	return p
}

func (*ElementListContext) IsElementListContext() {}

func NewElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementListContext {
	var p = new(ElementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_elementList

	return p
}

func (s *ElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserComma)
}

func (s *ElementListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserComma, i)
}

func (s *ElementListContext) AllArrayElement() []IArrayElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArrayElementContext)(nil)).Elem())
	var tst = make([]IArrayElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArrayElementContext)
		}
	}

	return tst
}

func (s *ElementListContext) ArrayElement(i int) IArrayElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArrayElementContext)
}

func (s *ElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterElementList(s)
	}
}

func (s *ElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitElementList(s)
	}
}

func (s *ElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ElementList() (localctx IElementListContext) {
	localctx = NewElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ABSLParserRULE_elementList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(643)
				p.Match(ABSLParserComma)
			}

		}
		p.SetState(648)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserEllipsis)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(649)
			p.ArrayElement()
		}

	}
	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(653)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ABSLParserComma {
				{
					p.SetState(652)
					p.Match(ABSLParserComma)
				}

				p.SetState(655)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(657)
				p.ArrayElement()
			}

		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
	}
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ABSLParserComma {
		{
			p.SetState(663)
			p.Match(ABSLParserComma)
		}

		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArrayElementContext is an interface to support dynamic dispatch.
type IArrayElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayElementContext differentiates from other interfaces.
	IsArrayElementContext()
}

type ArrayElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayElementContext() *ArrayElementContext {
	var p = new(ArrayElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_arrayElement
	return p
}

func (*ArrayElementContext) IsArrayElementContext() {}

func NewArrayElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayElementContext {
	var p = new(ArrayElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_arrayElement

	return p
}

func (s *ArrayElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayElementContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrayElementContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(ABSLParserEllipsis, 0)
}

func (s *ArrayElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterArrayElement(s)
	}
}

func (s *ArrayElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitArrayElement(s)
	}
}

func (s *ArrayElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitArrayElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ArrayElement() (localctx IArrayElementContext) {
	localctx = NewArrayElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ABSLParserRULE_arrayElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserEllipsis {
		{
			p.SetState(669)
			p.Match(ABSLParserEllipsis)
		}

	}
	{
		p.SetState(672)
		p.singleExpression(0)
	}

	return localctx
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_objectLiteral
	return p
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *ObjectLiteralContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *ObjectLiteralContext) AllPropertyAssignment() []IPropertyAssignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyAssignmentContext)(nil)).Elem())
	var tst = make([]IPropertyAssignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyAssignmentContext)
		}
	}

	return tst
}

func (s *ObjectLiteralContext) PropertyAssignment(i int) IPropertyAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyAssignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentContext)
}

func (s *ObjectLiteralContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserComma)
}

func (s *ObjectLiteralContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserComma, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ABSLParserRULE_objectLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.Match(ABSLParserOpenBrace)
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserEllipsis)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot)|(1<<ABSLParserMultiply))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserBreak-59))|(1<<(ABSLParserDo-59))|(1<<(ABSLParserInstanceof-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserCase-59))|(1<<(ABSLParserElse-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVar-59))|(1<<(ABSLParserCatch-59))|(1<<(ABSLParserFinally-59))|(1<<(ABSLParserReturn-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserContinue-59))|(1<<(ABSLParserFor-59))|(1<<(ABSLParserSwitch-59))|(1<<(ABSLParserWhile-59))|(1<<(ABSLParserDebugger-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserWith-91))|(1<<(ABSLParserDefault-91))|(1<<(ABSLParserIf-91))|(1<<(ABSLParserThrow-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserIn-91))|(1<<(ABSLParserTry-91))|(1<<(ABSLParserAs-91))|(1<<(ABSLParserFrom-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserEnum-91))|(1<<(ABSLParserExtends-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserConst-91))|(1<<(ABSLParserExport-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserImplements-91))|(1<<(ABSLParserLet-91))|(1<<(ABSLParserPrivate-91))|(1<<(ABSLParserPublic-91))|(1<<(ABSLParserInterface-91))|(1<<(ABSLParserPackage-91))|(1<<(ABSLParserProtected-91))|(1<<(ABSLParserStatic-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(675)
			p.PropertyAssignment()
		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(676)
					p.Match(ABSLParserComma)
				}
				{
					p.SetState(677)
					p.PropertyAssignment()
				}

			}
			p.SetState(682)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())
		}

	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserComma {
		{
			p.SetState(685)
			p.Match(ABSLParserComma)
		}

	}
	{
		p.SetState(688)
		p.Match(ABSLParserCloseBrace)
	}

	return localctx
}

// IPropertyAssignmentContext is an interface to support dynamic dispatch.
type IPropertyAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyAssignmentContext differentiates from other interfaces.
	IsPropertyAssignmentContext()
}

type PropertyAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAssignmentContext() *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_propertyAssignment
	return p
}

func (*PropertyAssignmentContext) IsPropertyAssignmentContext() {}

func NewPropertyAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAssignmentContext {
	var p = new(PropertyAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_propertyAssignment

	return p
}

func (s *PropertyAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAssignmentContext) CopyFrom(ctx *PropertyAssignmentContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PropertyAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PropertyExpressionAssignmentContext struct {
	*PropertyAssignmentContext
}

func NewPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyExpressionAssignmentContext {
	var p = new(PropertyExpressionAssignmentContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyExpressionAssignmentContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(ABSLParserColon, 0)
}

func (s *PropertyExpressionAssignmentContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPropertyExpressionAssignment(s)
	}
}

func (s *PropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComputedPropertyExpressionAssignmentContext struct {
	*PropertyAssignmentContext
}

func NewComputedPropertyExpressionAssignmentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComputedPropertyExpressionAssignmentContext {
	var p = new(ComputedPropertyExpressionAssignmentContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *ComputedPropertyExpressionAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedPropertyExpressionAssignmentContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *ComputedPropertyExpressionAssignmentContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ComputedPropertyExpressionAssignmentContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBracket, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) Colon() antlr.TerminalNode {
	return s.GetToken(ABSLParserColon, 0)
}

func (s *ComputedPropertyExpressionAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitComputedPropertyExpressionAssignment(s)
	}
}

func (s *ComputedPropertyExpressionAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitComputedPropertyExpressionAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyShorthandContext struct {
	*PropertyAssignmentContext
}

func NewPropertyShorthandContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyShorthandContext {
	var p = new(PropertyShorthandContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyShorthandContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyShorthandContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(ABSLParserEllipsis, 0)
}

func (s *PropertyShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPropertyShorthand(s)
	}
}

func (s *PropertyShorthandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPropertyShorthand(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertySetterContext struct {
	*PropertyAssignmentContext
}

func NewPropertySetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertySetterContext {
	var p = new(PropertySetterContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertySetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertySetterContext) Setter() ISetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertySetterContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *PropertySetterContext) FormalParameterArg() IFormalParameterArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterArgContext)
}

func (s *PropertySetterContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *PropertySetterContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *PropertySetterContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *PropertySetterContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *PropertySetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPropertySetter(s)
	}
}

func (s *PropertySetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPropertySetter(s)
	}
}

func (s *PropertySetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPropertySetter(s)

	default:
		return t.VisitChildren(s)
	}
}

type PropertyGetterContext struct {
	*PropertyAssignmentContext
}

func NewPropertyGetterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyGetterContext {
	var p = new(PropertyGetterContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *PropertyGetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyGetterContext) Getter() IGetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyGetterContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *PropertyGetterContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *PropertyGetterContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *PropertyGetterContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *PropertyGetterContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *PropertyGetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPropertyGetter(s)
	}
}

func (s *PropertyGetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPropertyGetter(s)
	}
}

func (s *PropertyGetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPropertyGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionPropertyContext struct {
	*PropertyAssignmentContext
}

func NewFunctionPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionPropertyContext {
	var p = new(FunctionPropertyContext)

	p.PropertyAssignmentContext = NewEmptyPropertyAssignmentContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PropertyAssignmentContext))

	return p
}

func (s *FunctionPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionPropertyContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *FunctionPropertyContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *FunctionPropertyContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *FunctionPropertyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *FunctionPropertyContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionPropertyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *FunctionPropertyContext) Async() antlr.TerminalNode {
	return s.GetToken(ABSLParserAsync, 0)
}

func (s *FunctionPropertyContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ABSLParserMultiply, 0)
}

func (s *FunctionPropertyContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterFunctionProperty(s)
	}
}

func (s *FunctionPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitFunctionProperty(s)
	}
}

func (s *FunctionPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitFunctionProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) PropertyAssignment() (localctx IPropertyAssignmentContext) {
	localctx = NewPropertyAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ABSLParserRULE_propertyAssignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(690)
			p.PropertyName()
		}
		{
			p.SetState(691)
			p.Match(ABSLParserColon)
		}
		{
			p.SetState(692)
			p.singleExpression(0)
		}

	case 2:
		localctx = NewComputedPropertyExpressionAssignmentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(694)
			p.Match(ABSLParserOpenBracket)
		}
		{
			p.SetState(695)
			p.singleExpression(0)
		}
		{
			p.SetState(696)
			p.Match(ABSLParserCloseBracket)
		}
		{
			p.SetState(697)
			p.Match(ABSLParserColon)
		}
		{
			p.SetState(698)
			p.singleExpression(0)
		}

	case 3:
		localctx = NewFunctionPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(701)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(700)
				p.Match(ABSLParserAsync)
			}

		}
		p.SetState(704)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserMultiply {
			{
				p.SetState(703)
				p.Match(ABSLParserMultiply)
			}

		}
		{
			p.SetState(706)
			p.PropertyName()
		}
		{
			p.SetState(707)
			p.Match(ABSLParserOpenParen)
		}
		p.SetState(709)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserEllipsis))) != 0) || _la == ABSLParserIdentifier {
			{
				p.SetState(708)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(711)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(712)
			p.Match(ABSLParserOpenBrace)
		}
		{
			p.SetState(713)
			p.FunctionBody()
		}
		{
			p.SetState(714)
			p.Match(ABSLParserCloseBrace)
		}

	case 4:
		localctx = NewPropertyGetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(716)
			p.Getter()
		}
		{
			p.SetState(717)
			p.Match(ABSLParserOpenParen)
		}
		{
			p.SetState(718)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(719)
			p.Match(ABSLParserOpenBrace)
		}
		{
			p.SetState(720)
			p.FunctionBody()
		}
		{
			p.SetState(721)
			p.Match(ABSLParserCloseBrace)
		}

	case 5:
		localctx = NewPropertySetterContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(723)
			p.Setter()
		}
		{
			p.SetState(724)
			p.Match(ABSLParserOpenParen)
		}
		{
			p.SetState(725)
			p.FormalParameterArg()
		}
		{
			p.SetState(726)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(727)
			p.Match(ABSLParserOpenBrace)
		}
		{
			p.SetState(728)
			p.FunctionBody()
		}
		{
			p.SetState(729)
			p.Match(ABSLParserCloseBrace)
		}

	case 6:
		localctx = NewPropertyShorthandContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(732)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserEllipsis {
			{
				p.SetState(731)
				p.Match(ABSLParserEllipsis)
			}

		}
		{
			p.SetState(734)
			p.singleExpression(0)
		}

	}

	return localctx
}

// IPropertyNameContext is an interface to support dynamic dispatch.
type IPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyNameContext differentiates from other interfaces.
	IsPropertyNameContext()
}

type PropertyNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyNameContext() *PropertyNameContext {
	var p = new(PropertyNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_propertyName
	return p
}

func (*PropertyNameContext) IsPropertyNameContext() {}

func NewPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyNameContext {
	var p = new(PropertyNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_propertyName

	return p
}

func (s *PropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyNameContext) IdentifierName() IIdentifierNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *PropertyNameContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserStringLiteral, 0)
}

func (s *PropertyNameContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *PropertyNameContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBracket, 0)
}

func (s *PropertyNameContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PropertyNameContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBracket, 0)
}

func (s *PropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPropertyName(s)
	}
}

func (s *PropertyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPropertyName(s)
	}
}

func (s *PropertyNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPropertyName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) PropertyName() (localctx IPropertyNameContext) {
	localctx = NewPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ABSLParserRULE_propertyName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(744)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserNullLiteral, ABSLParserBooleanLiteral, ABSLParserBreak, ABSLParserDo, ABSLParserInstanceof, ABSLParserTypeof, ABSLParserCase, ABSLParserElse, ABSLParserNew, ABSLParserVar, ABSLParserCatch, ABSLParserFinally, ABSLParserReturn, ABSLParserVoid, ABSLParserContinue, ABSLParserFor, ABSLParserSwitch, ABSLParserWhile, ABSLParserDebugger, ABSLParserFunction, ABSLParserThis, ABSLParserWith, ABSLParserDefault, ABSLParserIf, ABSLParserThrow, ABSLParserDelete, ABSLParserIn, ABSLParserTry, ABSLParserAs, ABSLParserFrom, ABSLParserClass, ABSLParserEnum, ABSLParserExtends, ABSLParserSuper, ABSLParserConst, ABSLParserExport, ABSLParserImport, ABSLParserAsync, ABSLParserAwait, ABSLParserImplements, ABSLParserLet, ABSLParserPrivate, ABSLParserPublic, ABSLParserInterface, ABSLParserPackage, ABSLParserProtected, ABSLParserStatic, ABSLParserYield, ABSLParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(737)
			p.IdentifierName()
		}

	case ABSLParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(738)
			p.Match(ABSLParserStringLiteral)
		}

	case ABSLParserDecimalLiteral, ABSLParserHexIntegerLiteral, ABSLParserOctalIntegerLiteral, ABSLParserOctalIntegerLiteral2, ABSLParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(739)
			p.NumericLiteral()
		}

	case ABSLParserOpenBracket:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(740)
			p.Match(ABSLParserOpenBracket)
		}
		{
			p.SetState(741)
			p.singleExpression(0)
		}
		{
			p.SetState(742)
			p.Match(ABSLParserCloseBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *ArgumentsContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *ArgumentsContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *ArgumentsContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentsContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserComma)
}

func (s *ArgumentsContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserComma, i)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ABSLParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Match(ABSLParserOpenParen)
	}
	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserRegularExpressionLiteral)|(1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenParen)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserEllipsis)|(1<<ABSLParserPlusPlus)|(1<<ABSLParserMinusMinus)|(1<<ABSLParserPlus)|(1<<ABSLParserMinus)|(1<<ABSLParserBitNot)|(1<<ABSLParserNot))) != 0) || (((_la-59)&-(0x1f+1)) == 0 && ((1<<uint((_la-59)))&((1<<(ABSLParserNullLiteral-59))|(1<<(ABSLParserBooleanLiteral-59))|(1<<(ABSLParserDecimalLiteral-59))|(1<<(ABSLParserHexIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral-59))|(1<<(ABSLParserOctalIntegerLiteral2-59))|(1<<(ABSLParserBinaryIntegerLiteral-59))|(1<<(ABSLParserBigHexIntegerLiteral-59))|(1<<(ABSLParserBigOctalIntegerLiteral-59))|(1<<(ABSLParserBigBinaryIntegerLiteral-59))|(1<<(ABSLParserBigDecimalIntegerLiteral-59))|(1<<(ABSLParserTypeof-59))|(1<<(ABSLParserNew-59))|(1<<(ABSLParserVoid-59))|(1<<(ABSLParserFunction-59)))) != 0) || (((_la-91)&-(0x1f+1)) == 0 && ((1<<uint((_la-91)))&((1<<(ABSLParserThis-91))|(1<<(ABSLParserDelete-91))|(1<<(ABSLParserClass-91))|(1<<(ABSLParserSuper-91))|(1<<(ABSLParserImport-91))|(1<<(ABSLParserAsync-91))|(1<<(ABSLParserAwait-91))|(1<<(ABSLParserYield-91))|(1<<(ABSLParserIdentifier-91))|(1<<(ABSLParserStringLiteral-91))|(1<<(ABSLParserTemplateStringLiteral-91)))) != 0) {
		{
			p.SetState(747)
			p.Argument()
		}
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(748)
					p.Match(ABSLParserComma)
				}
				{
					p.SetState(749)
					p.Argument()
				}

			}
			p.SetState(754)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext())
		}
		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserComma {
			{
				p.SetState(755)
				p.Match(ABSLParserComma)
			}

		}

	}
	{
		p.SetState(760)
		p.Match(ABSLParserCloseParen)
	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *ArgumentContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(ABSLParserEllipsis, 0)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ABSLParserRULE_argument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ABSLParserEllipsis {
		{
			p.SetState(762)
			p.Match(ABSLParserEllipsis)
		}

	}
	p.SetState(767)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(765)
			p.singleExpression(0)
		}

	case 2:
		{
			p.SetState(766)
			p.Match(ABSLParserIdentifier)
		}

	}

	return localctx
}

// IExpressionSequenceContext is an interface to support dynamic dispatch.
type IExpressionSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionSequenceContext differentiates from other interfaces.
	IsExpressionSequenceContext()
}

type ExpressionSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSequenceContext() *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_expressionSequence
	return p
}

func (*ExpressionSequenceContext) IsExpressionSequenceContext() {}

func NewExpressionSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSequenceContext {
	var p = new(ExpressionSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_expressionSequence

	return p
}

func (s *ExpressionSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSequenceContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionSequenceContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ExpressionSequenceContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(ABSLParserComma)
}

func (s *ExpressionSequenceContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(ABSLParserComma, i)
}

func (s *ExpressionSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitExpressionSequence(s)
	}
}

func (s *ExpressionSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitExpressionSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ExpressionSequence() (localctx IExpressionSequenceContext) {
	localctx = NewExpressionSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ABSLParserRULE_expressionSequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.singleExpression(0)
	}
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ABSLParserComma {
		{
			p.SetState(770)
			p.Match(ABSLParserComma)
		}
		{
			p.SetState(771)
			p.singleExpression(0)
		}

		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_singleExpression
	return p
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) CopyFrom(ctx *SingleExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TemplateStringExpressionContext struct {
	*SingleExpressionContext
}

func NewTemplateStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TemplateStringExpressionContext {
	var p = new(TemplateStringExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TemplateStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateStringExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TemplateStringExpressionContext) TemplateStringLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserTemplateStringLiteral, 0)
}

func (s *TemplateStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitTemplateStringExpression(s)
	}
}

func (s *TemplateStringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitTemplateStringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TernaryExpressionContext struct {
	*SingleExpressionContext
}

func NewTernaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TernaryExpressionContext {
	var p = new(TernaryExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TernaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *TernaryExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TernaryExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(ABSLParserQuestionMark, 0)
}

func (s *TernaryExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(ABSLParserColon, 0)
}

func (s *TernaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitTernaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalAndExpressionContext struct {
	*SingleExpressionContext
}

func NewLogicalAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalAndExpressionContext) And() antlr.TerminalNode {
	return s.GetToken(ABSLParserAnd, 0)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitLogicalAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PowerExpressionContext struct {
	*SingleExpressionContext
}

func NewPowerExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExpressionContext {
	var p = new(PowerExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PowerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *PowerExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PowerExpressionContext) Power() antlr.TerminalNode {
	return s.GetToken(ABSLParserPower, 0)
}

func (s *PowerExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPowerExpression(s)
	}
}

func (s *PowerExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPowerExpression(s)
	}
}

func (s *PowerExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPowerExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreIncrementExpressionContext struct {
	*SingleExpressionContext
}

func NewPreIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreIncrementExpressionContext {
	var p = new(PreIncrementExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(ABSLParserPlusPlus, 0)
}

func (s *PreIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPreIncrementExpression(s)
	}
}

func (s *PreIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPreIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjectLiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewObjectLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectLiteralExpressionContext {
	var p = new(ObjectLiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ObjectLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *ObjectLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitObjectLiteralExpression(s)
	}
}

func (s *ObjectLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitObjectLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MetaExpressionContext struct {
	*SingleExpressionContext
}

func NewMetaExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MetaExpressionContext {
	var p = new(MetaExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MetaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetaExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(ABSLParserNew, 0)
}

func (s *MetaExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(ABSLParserDot, 0)
}

func (s *MetaExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *MetaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterMetaExpression(s)
	}
}

func (s *MetaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitMetaExpression(s)
	}
}

func (s *MetaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitMetaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InExpressionContext struct {
	*SingleExpressionContext
}

func NewInExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InExpressionContext {
	var p = new(InExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *InExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *InExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InExpressionContext) In() antlr.TerminalNode {
	return s.GetToken(ABSLParserIn, 0)
}

func (s *InExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterInExpression(s)
	}
}

func (s *InExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitInExpression(s)
	}
}

func (s *InExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitInExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalOrExpressionContext struct {
	*SingleExpressionContext
}

func NewLogicalOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *LogicalOrExpressionContext) Or() antlr.TerminalNode {
	return s.GetToken(ABSLParserOr, 0)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitLogicalOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	*SingleExpressionContext
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Not() antlr.TerminalNode {
	return s.GetToken(ABSLParserNot, 0)
}

func (s *NotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreDecreaseExpressionContext struct {
	*SingleExpressionContext
}

func NewPreDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreDecreaseExpressionContext {
	var p = new(PreDecreaseExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PreDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(ABSLParserMinusMinus, 0)
}

func (s *PreDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PreDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPreDecreaseExpression(s)
	}
}

func (s *PreDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPreDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArgumentsExpressionContext struct {
	*SingleExpressionContext
}

func NewArgumentsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArgumentsExpressionContext {
	var p = new(ArgumentsExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArgumentsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArgumentsExpressionContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitArgumentsExpression(s)
	}
}

func (s *ArgumentsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitArgumentsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AwaitExpressionContext struct {
	*SingleExpressionContext
}

func NewAwaitExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AwaitExpressionContext {
	var p = new(AwaitExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AwaitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExpressionContext) Await() antlr.TerminalNode {
	return s.GetToken(ABSLParserAwait, 0)
}

func (s *AwaitExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AwaitExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterAwaitExpression(s)
	}
}

func (s *AwaitExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitAwaitExpression(s)
	}
}

func (s *AwaitExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitAwaitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ThisExpressionContext struct {
	*SingleExpressionContext
}

func NewThisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) This() antlr.TerminalNode {
	return s.GetToken(ABSLParserThis, 0)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

func (s *ThisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitThisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionExpressionContext struct {
	*SingleExpressionContext
}

func NewFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionExpressionContext {
	var p = new(FunctionExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *FunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionExpressionContext) AnoymousFunction() IAnoymousFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnoymousFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnoymousFunctionContext)
}

func (s *FunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitFunctionExpression(s)
	}
}

func (s *FunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryMinusExpressionContext struct {
	*SingleExpressionContext
}

func NewUnaryMinusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryMinusExpressionContext {
	var p = new(UnaryMinusExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryMinusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryMinusExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(ABSLParserMinus, 0)
}

func (s *UnaryMinusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryMinusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitUnaryMinusExpression(s)
	}
}

func (s *UnaryMinusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitUnaryMinusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentExpressionContext struct {
	*SingleExpressionContext
}

func NewAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentExpressionContext) Assign() antlr.TerminalNode {
	return s.GetToken(ABSLParserAssign, 0)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostDecreaseExpressionContext struct {
	*SingleExpressionContext
}

func NewPostDecreaseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostDecreaseExpressionContext {
	var p = new(PostDecreaseExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostDecreaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostDecreaseExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostDecreaseExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(ABSLParserMinusMinus, 0)
}

func (s *PostDecreaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPostDecreaseExpression(s)
	}
}

func (s *PostDecreaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPostDecreaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeofExpressionContext struct {
	*SingleExpressionContext
}

func NewTypeofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *TypeofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeofExpressionContext) Typeof() antlr.TerminalNode {
	return s.GetToken(ABSLParserTypeof, 0)
}

func (s *TypeofExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *TypeofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterTypeofExpression(s)
	}
}

func (s *TypeofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitTypeofExpression(s)
	}
}

func (s *TypeofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitTypeofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type InstanceofExpressionContext struct {
	*SingleExpressionContext
}

func NewInstanceofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceofExpressionContext {
	var p = new(InstanceofExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *InstanceofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *InstanceofExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *InstanceofExpressionContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(ABSLParserInstanceof, 0)
}

func (s *InstanceofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterInstanceofExpression(s)
	}
}

func (s *InstanceofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitInstanceofExpression(s)
	}
}

func (s *InstanceofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitInstanceofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryPlusExpressionContext struct {
	*SingleExpressionContext
}

func NewUnaryPlusExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryPlusExpressionContext {
	var p = new(UnaryPlusExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *UnaryPlusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPlusExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(ABSLParserPlus, 0)
}

func (s *UnaryPlusExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *UnaryPlusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitUnaryPlusExpression(s)
	}
}

func (s *UnaryPlusExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitUnaryPlusExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeleteExpressionContext struct {
	*SingleExpressionContext
}

func NewDeleteExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteExpressionContext {
	var p = new(DeleteExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *DeleteExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteExpressionContext) Delete() antlr.TerminalNode {
	return s.GetToken(ABSLParserDelete, 0)
}

func (s *DeleteExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *DeleteExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitDeleteExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImportExpressionContext struct {
	*SingleExpressionContext
}

func NewImportExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportExpressionContext {
	var p = new(ImportExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ImportExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportExpressionContext) Import() antlr.TerminalNode {
	return s.GetToken(ABSLParserImport, 0)
}

func (s *ImportExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *ImportExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ImportExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *ImportExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterImportExpression(s)
	}
}

func (s *ImportExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitImportExpression(s)
	}
}

func (s *ImportExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitImportExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityExpressionContext struct {
	*SingleExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *EqualityExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *EqualityExpressionContext) Equals_() antlr.TerminalNode {
	return s.GetToken(ABSLParserEquals_, 0)
}

func (s *EqualityExpressionContext) NotEquals() antlr.TerminalNode {
	return s.GetToken(ABSLParserNotEquals, 0)
}

func (s *EqualityExpressionContext) IdentityEquals() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentityEquals, 0)
}

func (s *EqualityExpressionContext) IdentityNotEquals() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentityNotEquals, 0)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitXOrExpressionContext struct {
	*SingleExpressionContext
}

func NewBitXOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitXOrExpressionContext {
	var p = new(BitXOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitXOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitXOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *BitXOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitXOrExpressionContext) BitXOr() antlr.TerminalNode {
	return s.GetToken(ABSLParserBitXOr, 0)
}

func (s *BitXOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterBitXOrExpression(s)
	}
}

func (s *BitXOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitBitXOrExpression(s)
	}
}

func (s *BitXOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitBitXOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SuperExpressionContext struct {
	*SingleExpressionContext
}

func NewSuperExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) Super() antlr.TerminalNode {
	return s.GetToken(ABSLParserSuper, 0)
}

func (s *SuperExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterSuperExpression(s)
	}
}

func (s *SuperExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitSuperExpression(s)
	}
}

func (s *SuperExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitSuperExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiplicativeExpressionContext struct {
	*SingleExpressionContext
}

func NewMultiplicativeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MultiplicativeExpressionContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ABSLParserMultiply, 0)
}

func (s *MultiplicativeExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(ABSLParserDivide, 0)
}

func (s *MultiplicativeExpressionContext) Modulus() antlr.TerminalNode {
	return s.GetToken(ABSLParserModulus, 0)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitShiftExpressionContext struct {
	*SingleExpressionContext
}

func NewBitShiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitShiftExpressionContext {
	var p = new(BitShiftExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitShiftExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *BitShiftExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitShiftExpressionContext) LeftShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(ABSLParserLeftShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftArithmetic() antlr.TerminalNode {
	return s.GetToken(ABSLParserRightShiftArithmetic, 0)
}

func (s *BitShiftExpressionContext) RightShiftLogical() antlr.TerminalNode {
	return s.GetToken(ABSLParserRightShiftLogical, 0)
}

func (s *BitShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitBitShiftExpression(s)
	}
}

func (s *BitShiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitBitShiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	*SingleExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *ParenthesizedExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *ParenthesizedExpressionContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdditiveExpressionContext struct {
	*SingleExpressionContext
}

func NewAdditiveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AdditiveExpressionContext) Plus() antlr.TerminalNode {
	return s.GetToken(ABSLParserPlus, 0)
}

func (s *AdditiveExpressionContext) Minus() antlr.TerminalNode {
	return s.GetToken(ABSLParserMinus, 0)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationalExpressionContext struct {
	*SingleExpressionContext
}

func NewRelationalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *RelationalExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *RelationalExpressionContext) LessThan() antlr.TerminalNode {
	return s.GetToken(ABSLParserLessThan, 0)
}

func (s *RelationalExpressionContext) MoreThan() antlr.TerminalNode {
	return s.GetToken(ABSLParserMoreThan, 0)
}

func (s *RelationalExpressionContext) LessThanEquals() antlr.TerminalNode {
	return s.GetToken(ABSLParserLessThanEquals, 0)
}

func (s *RelationalExpressionContext) GreaterThanEquals() antlr.TerminalNode {
	return s.GetToken(ABSLParserGreaterThanEquals, 0)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitRelationalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostIncrementExpressionContext struct {
	*SingleExpressionContext
}

func NewPostIncrementExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostIncrementExpressionContext {
	var p = new(PostIncrementExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *PostIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncrementExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *PostIncrementExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(ABSLParserPlusPlus, 0)
}

func (s *PostIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitPostIncrementExpression(s)
	}
}

func (s *PostIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitPostIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type YieldExpressionContext struct {
	*SingleExpressionContext
}

func NewYieldExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *YieldExpressionContext {
	var p = new(YieldExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *YieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldExpressionContext) YieldStatement() IYieldStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldStatementContext)
}

func (s *YieldExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterYieldExpression(s)
	}
}

func (s *YieldExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitYieldExpression(s)
	}
}

func (s *YieldExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitYieldExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitNotExpressionContext struct {
	*SingleExpressionContext
}

func NewBitNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitNotExpressionContext {
	var p = new(BitNotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitNotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitNotExpressionContext) BitNot() antlr.TerminalNode {
	return s.GetToken(ABSLParserBitNot, 0)
}

func (s *BitNotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitNotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitBitNotExpression(s)
	}
}

func (s *BitNotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitBitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NewExpressionContext struct {
	*SingleExpressionContext
}

func NewNewExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewExpressionContext {
	var p = new(NewExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *NewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExpressionContext) New() antlr.TerminalNode {
	return s.GetToken(ABSLParserNew, 0)
}

func (s *NewExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *NewExpressionContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterNewExpression(s)
	}
}

func (s *NewExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitNewExpression(s)
	}
}

func (s *NewExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitNewExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayLiteralExpressionContext struct {
	*SingleExpressionContext
}

func NewArrayLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralExpressionContext {
	var p = new(ArrayLiteralExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ArrayLiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *ArrayLiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitArrayLiteralExpression(s)
	}
}

func (s *ArrayLiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitArrayLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberDotExpressionContext struct {
	*SingleExpressionContext
}

func NewMemberDotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberDotExpressionContext {
	var p = new(MemberDotExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberDotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDotExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberDotExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(ABSLParserDot, 0)
}

func (s *MemberDotExpressionContext) IdentifierName() IIdentifierNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierNameContext)
}

func (s *MemberDotExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(ABSLParserQuestionMark, 0)
}

func (s *MemberDotExpressionContext) Hashtag() antlr.TerminalNode {
	return s.GetToken(ABSLParserHashtag, 0)
}

func (s *MemberDotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitMemberDotExpression(s)
	}
}

func (s *MemberDotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitMemberDotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ClassExpressionContext struct {
	*SingleExpressionContext
}

func NewClassExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClassExpressionContext {
	var p = new(ClassExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *ClassExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassExpressionContext) Class() antlr.TerminalNode {
	return s.GetToken(ABSLParserClass, 0)
}

func (s *ClassExpressionContext) ClassTail() IClassTailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTailContext)
}

func (s *ClassExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *ClassExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterClassExpression(s)
	}
}

func (s *ClassExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitClassExpression(s)
	}
}

func (s *ClassExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitClassExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberIndexExpressionContext struct {
	*SingleExpressionContext
}

func NewMemberIndexExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberIndexExpressionContext {
	var p = new(MemberIndexExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *MemberIndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberIndexExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *MemberIndexExpressionContext) OpenBracket() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBracket, 0)
}

func (s *MemberIndexExpressionContext) ExpressionSequence() IExpressionSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionSequenceContext)
}

func (s *MemberIndexExpressionContext) CloseBracket() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBracket, 0)
}

func (s *MemberIndexExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitMemberIndexExpression(s)
	}
}

func (s *MemberIndexExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitMemberIndexExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IdentifierExpressionContext struct {
	*SingleExpressionContext
}

func NewIdentifierExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierExpressionContext {
	var p = new(IdentifierExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *IdentifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *IdentifierExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitIdentifierExpression(s)
	}
}

func (s *IdentifierExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitIdentifierExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitAndExpressionContext struct {
	*SingleExpressionContext
}

func NewBitAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitAndExpressionContext {
	var p = new(BitAndExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitAndExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *BitAndExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitAndExpressionContext) BitAnd() antlr.TerminalNode {
	return s.GetToken(ABSLParserBitAnd, 0)
}

func (s *BitAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterBitAndExpression(s)
	}
}

func (s *BitAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitBitAndExpression(s)
	}
}

func (s *BitAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitBitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitOrExpressionContext struct {
	*SingleExpressionContext
}

func NewBitOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitOrExpressionContext {
	var p = new(BitOrExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *BitOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOrExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *BitOrExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *BitOrExpressionContext) BitOr() antlr.TerminalNode {
	return s.GetToken(ABSLParserBitOr, 0)
}

func (s *BitOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterBitOrExpression(s)
	}
}

func (s *BitOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitBitOrExpression(s)
	}
}

func (s *BitOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitBitOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignmentOperatorExpressionContext struct {
	*SingleExpressionContext
}

func NewAssignmentOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentOperatorExpressionContext {
	var p = new(AssignmentOperatorExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *AssignmentOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *AssignmentOperatorExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *AssignmentOperatorExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitAssignmentOperatorExpression(s)
	}
}

func (s *AssignmentOperatorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitAssignmentOperatorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type VoidExpressionContext struct {
	*SingleExpressionContext
}

func NewVoidExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VoidExpressionContext {
	var p = new(VoidExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *VoidExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VoidExpressionContext) Void() antlr.TerminalNode {
	return s.GetToken(ABSLParserVoid, 0)
}

func (s *VoidExpressionContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *VoidExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterVoidExpression(s)
	}
}

func (s *VoidExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitVoidExpression(s)
	}
}

func (s *VoidExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitVoidExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CoalesceExpressionContext struct {
	*SingleExpressionContext
}

func NewCoalesceExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CoalesceExpressionContext {
	var p = new(CoalesceExpressionContext)

	p.SingleExpressionContext = NewEmptySingleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SingleExpressionContext))

	return p
}

func (s *CoalesceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CoalesceExpressionContext) AllSingleExpression() []ISingleExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem())
	var tst = make([]ISingleExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleExpressionContext)
		}
	}

	return tst
}

func (s *CoalesceExpressionContext) SingleExpression(i int) ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *CoalesceExpressionContext) NullCoalesce() antlr.TerminalNode {
	return s.GetToken(ABSLParserNullCoalesce, 0)
}

func (s *CoalesceExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterCoalesceExpression(s)
	}
}

func (s *CoalesceExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitCoalesceExpression(s)
	}
}

func (s *CoalesceExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitCoalesceExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) SingleExpression() (localctx ISingleExpressionContext) {
	return p.singleExpression(0)
}

func (p *ABSLParser) singleExpression(_p int) (localctx ISingleExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISingleExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 118
	p.EnterRecursionRule(localctx, 118, ABSLParserRULE_singleExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(778)
			p.AnoymousFunction()
		}

	case 2:
		localctx = NewClassExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(779)
			p.Match(ABSLParserClass)
		}
		p.SetState(781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserIdentifier {
			{
				p.SetState(780)
				p.Match(ABSLParserIdentifier)
			}

		}
		{
			p.SetState(783)
			p.ClassTail()
		}

	case 3:
		localctx = NewNewExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(784)
			p.Match(ABSLParserNew)
		}
		{
			p.SetState(785)
			p.singleExpression(0)
		}
		p.SetState(787)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(786)
				p.Arguments()
			}

		}

	case 4:
		localctx = NewMetaExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(789)
			p.Match(ABSLParserNew)
		}
		{
			p.SetState(790)
			p.Match(ABSLParserDot)
		}
		{
			p.SetState(791)
			p.Match(ABSLParserIdentifier)
		}

	case 5:
		localctx = NewDeleteExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(792)
			p.Match(ABSLParserDelete)
		}
		{
			p.SetState(793)
			p.singleExpression(37)
		}

	case 6:
		localctx = NewVoidExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(794)
			p.Match(ABSLParserVoid)
		}
		{
			p.SetState(795)
			p.singleExpression(36)
		}

	case 7:
		localctx = NewTypeofExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(796)
			p.Match(ABSLParserTypeof)
		}
		{
			p.SetState(797)
			p.singleExpression(35)
		}

	case 8:
		localctx = NewPreIncrementExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(798)
			p.Match(ABSLParserPlusPlus)
		}
		{
			p.SetState(799)
			p.singleExpression(34)
		}

	case 9:
		localctx = NewPreDecreaseExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(800)
			p.Match(ABSLParserMinusMinus)
		}
		{
			p.SetState(801)
			p.singleExpression(33)
		}

	case 10:
		localctx = NewUnaryPlusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(802)
			p.Match(ABSLParserPlus)
		}
		{
			p.SetState(803)
			p.singleExpression(32)
		}

	case 11:
		localctx = NewUnaryMinusExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(804)
			p.Match(ABSLParserMinus)
		}
		{
			p.SetState(805)
			p.singleExpression(31)
		}

	case 12:
		localctx = NewBitNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(806)
			p.Match(ABSLParserBitNot)
		}
		{
			p.SetState(807)
			p.singleExpression(30)
		}

	case 13:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(808)
			p.Match(ABSLParserNot)
		}
		{
			p.SetState(809)
			p.singleExpression(29)
		}

	case 14:
		localctx = NewAwaitExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(810)
			p.Match(ABSLParserAwait)
		}
		{
			p.SetState(811)
			p.singleExpression(28)
		}

	case 15:
		localctx = NewImportExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(812)
			p.Match(ABSLParserImport)
		}
		{
			p.SetState(813)
			p.Match(ABSLParserOpenParen)
		}
		{
			p.SetState(814)
			p.singleExpression(0)
		}
		{
			p.SetState(815)
			p.Match(ABSLParserCloseParen)
		}

	case 16:
		localctx = NewYieldExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(817)
			p.YieldStatement()
		}

	case 17:
		localctx = NewThisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(818)
			p.Match(ABSLParserThis)
		}

	case 18:
		localctx = NewIdentifierExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(819)
			p.Match(ABSLParserIdentifier)
		}

	case 19:
		localctx = NewSuperExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(820)
			p.Match(ABSLParserSuper)
		}

	case 20:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(821)
			p.Literal()
		}

	case 21:
		localctx = NewArrayLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(822)
			p.ArrayLiteral()
		}

	case 22:
		localctx = NewObjectLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(823)
			p.ObjectLiteral()
		}

	case 23:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(824)
			p.Match(ABSLParserOpenParen)
		}
		{
			p.SetState(825)
			p.ExpressionSequence()
		}
		{
			p.SetState(826)
			p.Match(ABSLParserCloseParen)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(907)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(830)

				if !(p.Precpred(p.GetParserRuleContext(), 27)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 27)", ""))
				}
				{
					p.SetState(831)
					p.Match(ABSLParserPower)
				}
				{
					p.SetState(832)
					p.singleExpression(27)
				}

			case 2:
				localctx = NewMultiplicativeExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(833)

				if !(p.Precpred(p.GetParserRuleContext(), 26)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 26)", ""))
				}
				{
					p.SetState(834)
					_la = p.GetTokenStream().LA(1)

					if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserMultiply)|(1<<ABSLParserDivide)|(1<<ABSLParserModulus))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(835)
					p.singleExpression(27)
				}

			case 3:
				localctx = NewAdditiveExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(836)

				if !(p.Precpred(p.GetParserRuleContext(), 25)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 25)", ""))
				}
				{
					p.SetState(837)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ABSLParserPlus || _la == ABSLParserMinus) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(838)
					p.singleExpression(26)
				}

			case 4:
				localctx = NewCoalesceExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(839)

				if !(p.Precpred(p.GetParserRuleContext(), 24)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 24)", ""))
				}
				{
					p.SetState(840)
					p.Match(ABSLParserNullCoalesce)
				}
				{
					p.SetState(841)
					p.singleExpression(25)
				}

			case 5:
				localctx = NewBitShiftExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(842)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
				}
				{
					p.SetState(843)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-30)&-(0x1f+1)) == 0 && ((1<<uint((_la-30)))&((1<<(ABSLParserRightShiftArithmetic-30))|(1<<(ABSLParserLeftShiftArithmetic-30))|(1<<(ABSLParserRightShiftLogical-30)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(844)
					p.singleExpression(24)
				}

			case 6:
				localctx = NewRelationalExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(845)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				{
					p.SetState(846)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(ABSLParserLessThan-33))|(1<<(ABSLParserMoreThan-33))|(1<<(ABSLParserLessThanEquals-33))|(1<<(ABSLParserGreaterThanEquals-33)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(847)
					p.singleExpression(23)
				}

			case 7:
				localctx = NewInstanceofExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(848)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(849)
					p.Match(ABSLParserInstanceof)
				}
				{
					p.SetState(850)
					p.singleExpression(22)
				}

			case 8:
				localctx = NewInExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(851)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(852)
					p.Match(ABSLParserIn)
				}
				{
					p.SetState(853)
					p.singleExpression(21)
				}

			case 9:
				localctx = NewEqualityExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(854)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(855)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(ABSLParserEquals_-37))|(1<<(ABSLParserNotEquals-37))|(1<<(ABSLParserIdentityEquals-37))|(1<<(ABSLParserIdentityNotEquals-37)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(856)
					p.singleExpression(20)
				}

			case 10:
				localctx = NewBitAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(857)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(858)
					p.Match(ABSLParserBitAnd)
				}
				{
					p.SetState(859)
					p.singleExpression(19)
				}

			case 11:
				localctx = NewBitXOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(860)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(861)
					p.Match(ABSLParserBitXOr)
				}
				{
					p.SetState(862)
					p.singleExpression(18)
				}

			case 12:
				localctx = NewBitOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(863)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(864)
					p.Match(ABSLParserBitOr)
				}
				{
					p.SetState(865)
					p.singleExpression(17)
				}

			case 13:
				localctx = NewLogicalAndExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(866)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(867)
					p.Match(ABSLParserAnd)
				}
				{
					p.SetState(868)
					p.singleExpression(16)
				}

			case 14:
				localctx = NewLogicalOrExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(869)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(870)
					p.Match(ABSLParserOr)
				}
				{
					p.SetState(871)
					p.singleExpression(15)
				}

			case 15:
				localctx = NewTernaryExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(872)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(873)
					p.Match(ABSLParserQuestionMark)
				}
				{
					p.SetState(874)
					p.singleExpression(0)
				}
				{
					p.SetState(875)
					p.Match(ABSLParserColon)
				}
				{
					p.SetState(876)
					p.singleExpression(14)
				}

			case 16:
				localctx = NewAssignmentExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(878)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(879)
					p.Match(ABSLParserAssign)
				}
				{
					p.SetState(880)
					p.singleExpression(12)
				}

			case 17:
				localctx = NewAssignmentOperatorExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(881)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(882)
					p.AssignmentOperator()
				}
				{
					p.SetState(883)
					p.singleExpression(11)
				}

			case 18:
				localctx = NewMemberIndexExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(885)

				if !(p.Precpred(p.GetParserRuleContext(), 44)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 44)", ""))
				}
				{
					p.SetState(886)
					p.Match(ABSLParserOpenBracket)
				}
				{
					p.SetState(887)
					p.ExpressionSequence()
				}
				{
					p.SetState(888)
					p.Match(ABSLParserCloseBracket)
				}

			case 19:
				localctx = NewMemberDotExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(890)

				if !(p.Precpred(p.GetParserRuleContext(), 43)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 43)", ""))
				}
				p.SetState(892)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ABSLParserQuestionMark {
					{
						p.SetState(891)
						p.Match(ABSLParserQuestionMark)
					}

				}
				{
					p.SetState(894)
					p.Match(ABSLParserDot)
				}
				p.SetState(896)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == ABSLParserHashtag {
					{
						p.SetState(895)
						p.Match(ABSLParserHashtag)
					}

				}
				{
					p.SetState(898)
					p.IdentifierName()
				}

			case 20:
				localctx = NewArgumentsExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(899)

				if !(p.Precpred(p.GetParserRuleContext(), 42)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 42)", ""))
				}
				{
					p.SetState(900)
					p.Arguments()
				}

			case 21:
				localctx = NewPostIncrementExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(901)

				if !(p.Precpred(p.GetParserRuleContext(), 39)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 39)", ""))
				}
				{
					p.SetState(902)
					p.Match(ABSLParserPlusPlus)
				}

			case 22:
				localctx = NewPostDecreaseExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(903)

				if !(p.Precpred(p.GetParserRuleContext(), 38)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 38)", ""))
				}
				{
					p.SetState(904)
					p.Match(ABSLParserMinusMinus)
				}

			case 23:
				localctx = NewTemplateStringExpressionContext(p, NewSingleExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ABSLParserRULE_singleExpression)
				p.SetState(905)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(906)
					p.Match(ABSLParserTemplateStringLiteral)
				}

			}

		}
		p.SetState(911)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())
	}

	return localctx
}

// IAssignableContext is an interface to support dynamic dispatch.
type IAssignableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignableContext differentiates from other interfaces.
	IsAssignableContext()
}

type AssignableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableContext() *AssignableContext {
	var p = new(AssignableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_assignable
	return p
}

func (*AssignableContext) IsAssignableContext() {}

func NewAssignableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableContext {
	var p = new(AssignableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_assignable

	return p
}

func (s *AssignableContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *AssignableContext) ArrayLiteral() IArrayLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *AssignableContext) ObjectLiteral() IObjectLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *AssignableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterAssignable(s)
	}
}

func (s *AssignableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitAssignable(s)
	}
}

func (s *AssignableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitAssignable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Assignable() (localctx IAssignableContext) {
	localctx = NewAssignableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ABSLParserRULE_assignable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(915)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(912)
			p.Match(ABSLParserIdentifier)
		}

	case ABSLParserOpenBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(913)
			p.ArrayLiteral()
		}

	case ABSLParserOpenBrace:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(914)
			p.ObjectLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnoymousFunctionContext is an interface to support dynamic dispatch.
type IAnoymousFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnoymousFunctionContext differentiates from other interfaces.
	IsAnoymousFunctionContext()
}

type AnoymousFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnoymousFunctionContext() *AnoymousFunctionContext {
	var p = new(AnoymousFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_anoymousFunction
	return p
}

func (*AnoymousFunctionContext) IsAnoymousFunctionContext() {}

func NewAnoymousFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnoymousFunctionContext {
	var p = new(AnoymousFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_anoymousFunction

	return p
}

func (s *AnoymousFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnoymousFunctionContext) CopyFrom(ctx *AnoymousFunctionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AnoymousFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnoymousFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AnoymousFunctionDeclContext struct {
	*AnoymousFunctionContext
}

func NewAnoymousFunctionDeclContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnoymousFunctionDeclContext {
	var p = new(AnoymousFunctionDeclContext)

	p.AnoymousFunctionContext = NewEmptyAnoymousFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AnoymousFunctionContext))

	return p
}

func (s *AnoymousFunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnoymousFunctionDeclContext) Function() antlr.TerminalNode {
	return s.GetToken(ABSLParserFunction, 0)
}

func (s *AnoymousFunctionDeclContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *AnoymousFunctionDeclContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *AnoymousFunctionDeclContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *AnoymousFunctionDeclContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *AnoymousFunctionDeclContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *AnoymousFunctionDeclContext) Async() antlr.TerminalNode {
	return s.GetToken(ABSLParserAsync, 0)
}

func (s *AnoymousFunctionDeclContext) Multiply() antlr.TerminalNode {
	return s.GetToken(ABSLParserMultiply, 0)
}

func (s *AnoymousFunctionDeclContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *AnoymousFunctionDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterAnoymousFunctionDecl(s)
	}
}

func (s *AnoymousFunctionDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitAnoymousFunctionDecl(s)
	}
}

func (s *AnoymousFunctionDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitAnoymousFunctionDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrowFunctionContext struct {
	*AnoymousFunctionContext
}

func NewArrowFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowFunctionContext {
	var p = new(ArrowFunctionContext)

	p.AnoymousFunctionContext = NewEmptyAnoymousFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AnoymousFunctionContext))

	return p
}

func (s *ArrowFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionContext) ArrowFunctionParameters() IArrowFunctionParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrowFunctionParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionParametersContext)
}

func (s *ArrowFunctionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ABSLParserARROW, 0)
}

func (s *ArrowFunctionContext) ArrowFunctionBody() IArrowFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrowFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrowFunctionBodyContext)
}

func (s *ArrowFunctionContext) Async() antlr.TerminalNode {
	return s.GetToken(ABSLParserAsync, 0)
}

func (s *ArrowFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterArrowFunction(s)
	}
}

func (s *ArrowFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitArrowFunction(s)
	}
}

func (s *ArrowFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitArrowFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionDeclContext struct {
	*AnoymousFunctionContext
}

func NewFunctionDeclContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionDeclContext {
	var p = new(FunctionDeclContext)

	p.AnoymousFunctionContext = NewEmptyAnoymousFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AnoymousFunctionContext))

	return p
}

func (s *FunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *FunctionDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitFunctionDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) AnoymousFunction() (localctx IAnoymousFunctionContext) {
	localctx = NewAnoymousFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ABSLParserRULE_anoymousFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(941)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFunctionDeclContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(917)
			p.FunctionDeclaration()
		}

	case 2:
		localctx = NewAnoymousFunctionDeclContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(919)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserAsync {
			{
				p.SetState(918)
				p.Match(ABSLParserAsync)
			}

		}
		{
			p.SetState(921)
			p.Match(ABSLParserFunction)
		}
		p.SetState(923)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserMultiply {
			{
				p.SetState(922)
				p.Match(ABSLParserMultiply)
			}

		}
		{
			p.SetState(925)
			p.Match(ABSLParserOpenParen)
		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserEllipsis))) != 0) || _la == ABSLParserIdentifier {
			{
				p.SetState(926)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(929)
			p.Match(ABSLParserCloseParen)
		}
		{
			p.SetState(930)
			p.Match(ABSLParserOpenBrace)
		}
		{
			p.SetState(931)
			p.FunctionBody()
		}
		{
			p.SetState(932)
			p.Match(ABSLParserCloseBrace)
		}

	case 3:
		localctx = NewArrowFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ABSLParserAsync {
			{
				p.SetState(934)
				p.Match(ABSLParserAsync)
			}

		}
		{
			p.SetState(937)
			p.ArrowFunctionParameters()
		}
		{
			p.SetState(938)
			p.Match(ABSLParserARROW)
		}
		{
			p.SetState(939)
			p.ArrowFunctionBody()
		}

	}

	return localctx
}

// IArrowFunctionParametersContext is an interface to support dynamic dispatch.
type IArrowFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowFunctionParametersContext differentiates from other interfaces.
	IsArrowFunctionParametersContext()
}

type ArrowFunctionParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionParametersContext() *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_arrowFunctionParameters
	return p
}

func (*ArrowFunctionParametersContext) IsArrowFunctionParametersContext() {}

func NewArrowFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionParametersContext {
	var p = new(ArrowFunctionParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_arrowFunctionParameters

	return p
}

func (s *ArrowFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionParametersContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *ArrowFunctionParametersContext) OpenParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenParen, 0)
}

func (s *ArrowFunctionParametersContext) CloseParen() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseParen, 0)
}

func (s *ArrowFunctionParametersContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ArrowFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitArrowFunctionParameters(s)
	}
}

func (s *ArrowFunctionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitArrowFunctionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ArrowFunctionParameters() (localctx IArrowFunctionParametersContext) {
	localctx = NewArrowFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ABSLParserRULE_arrowFunctionParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(949)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(943)
			p.Match(ABSLParserIdentifier)
		}

	case ABSLParserOpenParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(944)
			p.Match(ABSLParserOpenParen)
		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ABSLParserOpenBracket)|(1<<ABSLParserOpenBrace)|(1<<ABSLParserEllipsis))) != 0) || _la == ABSLParserIdentifier {
			{
				p.SetState(945)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(948)
			p.Match(ABSLParserCloseParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrowFunctionBodyContext is an interface to support dynamic dispatch.
type IArrowFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowFunctionBodyContext differentiates from other interfaces.
	IsArrowFunctionBodyContext()
}

type ArrowFunctionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowFunctionBodyContext() *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_arrowFunctionBody
	return p
}

func (*ArrowFunctionBodyContext) IsArrowFunctionBodyContext() {}

func NewArrowFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowFunctionBodyContext {
	var p = new(ArrowFunctionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_arrowFunctionBody

	return p
}

func (s *ArrowFunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowFunctionBodyContext) SingleExpression() ISingleExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleExpressionContext)
}

func (s *ArrowFunctionBodyContext) OpenBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserOpenBrace, 0)
}

func (s *ArrowFunctionBodyContext) FunctionBody() IFunctionBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *ArrowFunctionBodyContext) CloseBrace() antlr.TerminalNode {
	return s.GetToken(ABSLParserCloseBrace, 0)
}

func (s *ArrowFunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowFunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrowFunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterArrowFunctionBody(s)
	}
}

func (s *ArrowFunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitArrowFunctionBody(s)
	}
}

func (s *ArrowFunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitArrowFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ArrowFunctionBody() (localctx IArrowFunctionBodyContext) {
	localctx = NewArrowFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ABSLParserRULE_arrowFunctionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(956)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(951)
			p.singleExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(952)
			p.Match(ABSLParserOpenBrace)
		}
		{
			p.SetState(953)
			p.FunctionBody()
		}
		{
			p.SetState(954)
			p.Match(ABSLParserCloseBrace)
		}

	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) MultiplyAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserMultiplyAssign, 0)
}

func (s *AssignmentOperatorContext) DivideAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserDivideAssign, 0)
}

func (s *AssignmentOperatorContext) ModulusAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserModulusAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserLeftShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftArithmeticAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserRightShiftArithmeticAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftLogicalAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserRightShiftLogicalAssign, 0)
}

func (s *AssignmentOperatorContext) BitAndAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserBitAndAssign, 0)
}

func (s *AssignmentOperatorContext) BitXorAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserBitXorAssign, 0)
}

func (s *AssignmentOperatorContext) BitOrAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserBitOrAssign, 0)
}

func (s *AssignmentOperatorContext) PowerAssign() antlr.TerminalNode {
	return s.GetToken(ABSLParserPowerAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ABSLParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(958)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-46)&-(0x1f+1)) == 0 && ((1<<uint((_la-46)))&((1<<(ABSLParserMultiplyAssign-46))|(1<<(ABSLParserDivideAssign-46))|(1<<(ABSLParserModulusAssign-46))|(1<<(ABSLParserPlusAssign-46))|(1<<(ABSLParserMinusAssign-46))|(1<<(ABSLParserLeftShiftArithmeticAssign-46))|(1<<(ABSLParserRightShiftArithmeticAssign-46))|(1<<(ABSLParserRightShiftLogicalAssign-46))|(1<<(ABSLParserBitAndAssign-46))|(1<<(ABSLParserBitXorAssign-46))|(1<<(ABSLParserBitOrAssign-46))|(1<<(ABSLParserPowerAssign-46)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserNullLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserBooleanLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserStringLiteral, 0)
}

func (s *LiteralContext) TemplateStringLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserTemplateStringLiteral, 0)
}

func (s *LiteralContext) RegularExpressionLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserRegularExpressionLiteral, 0)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) BigintLiteral() IBigintLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBigintLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBigintLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ABSLParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(967)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserNullLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(960)
			p.Match(ABSLParserNullLiteral)
		}

	case ABSLParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(961)
			p.Match(ABSLParserBooleanLiteral)
		}

	case ABSLParserStringLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(962)
			p.Match(ABSLParserStringLiteral)
		}

	case ABSLParserTemplateStringLiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(963)
			p.Match(ABSLParserTemplateStringLiteral)
		}

	case ABSLParserRegularExpressionLiteral:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(964)
			p.Match(ABSLParserRegularExpressionLiteral)
		}

	case ABSLParserDecimalLiteral, ABSLParserHexIntegerLiteral, ABSLParserOctalIntegerLiteral, ABSLParserOctalIntegerLiteral2, ABSLParserBinaryIntegerLiteral:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(965)
			p.NumericLiteral()
		}

	case ABSLParserBigHexIntegerLiteral, ABSLParserBigOctalIntegerLiteral, ABSLParserBigBinaryIntegerLiteral, ABSLParserBigDecimalIntegerLiteral:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(966)
			p.BigintLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_numericLiteral
	return p
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) DecimalLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserDecimalLiteral, 0)
}

func (s *NumericLiteralContext) HexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserHexIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserOctalIntegerLiteral, 0)
}

func (s *NumericLiteralContext) OctalIntegerLiteral2() antlr.TerminalNode {
	return s.GetToken(ABSLParserOctalIntegerLiteral2, 0)
}

func (s *NumericLiteralContext) BinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserBinaryIntegerLiteral, 0)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) NumericLiteral() (localctx INumericLiteralContext) {
	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ABSLParserRULE_numericLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(ABSLParserDecimalLiteral-61))|(1<<(ABSLParserHexIntegerLiteral-61))|(1<<(ABSLParserOctalIntegerLiteral-61))|(1<<(ABSLParserOctalIntegerLiteral2-61))|(1<<(ABSLParserBinaryIntegerLiteral-61)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBigintLiteralContext is an interface to support dynamic dispatch.
type IBigintLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBigintLiteralContext differentiates from other interfaces.
	IsBigintLiteralContext()
}

type BigintLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBigintLiteralContext() *BigintLiteralContext {
	var p = new(BigintLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_bigintLiteral
	return p
}

func (*BigintLiteralContext) IsBigintLiteralContext() {}

func NewBigintLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BigintLiteralContext {
	var p = new(BigintLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_bigintLiteral

	return p
}

func (s *BigintLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BigintLiteralContext) BigDecimalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserBigDecimalIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigHexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserBigHexIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigOctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserBigOctalIntegerLiteral, 0)
}

func (s *BigintLiteralContext) BigBinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserBigBinaryIntegerLiteral, 0)
}

func (s *BigintLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BigintLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BigintLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterBigintLiteral(s)
	}
}

func (s *BigintLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitBigintLiteral(s)
	}
}

func (s *BigintLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitBigintLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) BigintLiteral() (localctx IBigintLiteralContext) {
	localctx = NewBigintLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ABSLParserRULE_bigintLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(971)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(ABSLParserBigHexIntegerLiteral-66))|(1<<(ABSLParserBigOctalIntegerLiteral-66))|(1<<(ABSLParserBigBinaryIntegerLiteral-66))|(1<<(ABSLParserBigDecimalIntegerLiteral-66)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierNameContext is an interface to support dynamic dispatch.
type IIdentifierNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierNameContext differentiates from other interfaces.
	IsIdentifierNameContext()
}

type IdentifierNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierNameContext() *IdentifierNameContext {
	var p = new(IdentifierNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_identifierName
	return p
}

func (*IdentifierNameContext) IsIdentifierNameContext() {}

func NewIdentifierNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierNameContext {
	var p = new(IdentifierNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_identifierName

	return p
}

func (s *IdentifierNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *IdentifierNameContext) ReservedWord() IReservedWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReservedWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReservedWordContext)
}

func (s *IdentifierNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterIdentifierName(s)
	}
}

func (s *IdentifierNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitIdentifierName(s)
	}
}

func (s *IdentifierNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitIdentifierName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) IdentifierName() (localctx IIdentifierNameContext) {
	localctx = NewIdentifierNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ABSLParserRULE_identifierName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(975)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(973)
			p.Match(ABSLParserIdentifier)
		}

	case ABSLParserNullLiteral, ABSLParserBooleanLiteral, ABSLParserBreak, ABSLParserDo, ABSLParserInstanceof, ABSLParserTypeof, ABSLParserCase, ABSLParserElse, ABSLParserNew, ABSLParserVar, ABSLParserCatch, ABSLParserFinally, ABSLParserReturn, ABSLParserVoid, ABSLParserContinue, ABSLParserFor, ABSLParserSwitch, ABSLParserWhile, ABSLParserDebugger, ABSLParserFunction, ABSLParserThis, ABSLParserWith, ABSLParserDefault, ABSLParserIf, ABSLParserThrow, ABSLParserDelete, ABSLParserIn, ABSLParserTry, ABSLParserAs, ABSLParserFrom, ABSLParserClass, ABSLParserEnum, ABSLParserExtends, ABSLParserSuper, ABSLParserConst, ABSLParserExport, ABSLParserImport, ABSLParserAsync, ABSLParserAwait, ABSLParserImplements, ABSLParserLet, ABSLParserPrivate, ABSLParserPublic, ABSLParserInterface, ABSLParserPackage, ABSLParserProtected, ABSLParserStatic, ABSLParserYield:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(974)
			p.ReservedWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_reservedWord
	return p
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReservedWordContext) Keyword() IKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *ReservedWordContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserNullLiteral, 0)
}

func (s *ReservedWordContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(ABSLParserBooleanLiteral, 0)
}

func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterReservedWord(s)
	}
}

func (s *ReservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitReservedWord(s)
	}
}

func (s *ReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) ReservedWord() (localctx IReservedWordContext) {
	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ABSLParserRULE_reservedWord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(980)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ABSLParserBreak, ABSLParserDo, ABSLParserInstanceof, ABSLParserTypeof, ABSLParserCase, ABSLParserElse, ABSLParserNew, ABSLParserVar, ABSLParserCatch, ABSLParserFinally, ABSLParserReturn, ABSLParserVoid, ABSLParserContinue, ABSLParserFor, ABSLParserSwitch, ABSLParserWhile, ABSLParserDebugger, ABSLParserFunction, ABSLParserThis, ABSLParserWith, ABSLParserDefault, ABSLParserIf, ABSLParserThrow, ABSLParserDelete, ABSLParserIn, ABSLParserTry, ABSLParserAs, ABSLParserFrom, ABSLParserClass, ABSLParserEnum, ABSLParserExtends, ABSLParserSuper, ABSLParserConst, ABSLParserExport, ABSLParserImport, ABSLParserAsync, ABSLParserAwait, ABSLParserImplements, ABSLParserLet, ABSLParserPrivate, ABSLParserPublic, ABSLParserInterface, ABSLParserPackage, ABSLParserProtected, ABSLParserStatic, ABSLParserYield:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.Keyword()
		}

	case ABSLParserNullLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(978)
			p.Match(ABSLParserNullLiteral)
		}

	case ABSLParserBooleanLiteral:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(979)
			p.Match(ABSLParserBooleanLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_keyword
	return p
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) Break() antlr.TerminalNode {
	return s.GetToken(ABSLParserBreak, 0)
}

func (s *KeywordContext) Do() antlr.TerminalNode {
	return s.GetToken(ABSLParserDo, 0)
}

func (s *KeywordContext) Instanceof() antlr.TerminalNode {
	return s.GetToken(ABSLParserInstanceof, 0)
}

func (s *KeywordContext) Typeof() antlr.TerminalNode {
	return s.GetToken(ABSLParserTypeof, 0)
}

func (s *KeywordContext) Case() antlr.TerminalNode {
	return s.GetToken(ABSLParserCase, 0)
}

func (s *KeywordContext) Else() antlr.TerminalNode {
	return s.GetToken(ABSLParserElse, 0)
}

func (s *KeywordContext) New() antlr.TerminalNode {
	return s.GetToken(ABSLParserNew, 0)
}

func (s *KeywordContext) Var() antlr.TerminalNode {
	return s.GetToken(ABSLParserVar, 0)
}

func (s *KeywordContext) Catch() antlr.TerminalNode {
	return s.GetToken(ABSLParserCatch, 0)
}

func (s *KeywordContext) Finally() antlr.TerminalNode {
	return s.GetToken(ABSLParserFinally, 0)
}

func (s *KeywordContext) Return() antlr.TerminalNode {
	return s.GetToken(ABSLParserReturn, 0)
}

func (s *KeywordContext) Void() antlr.TerminalNode {
	return s.GetToken(ABSLParserVoid, 0)
}

func (s *KeywordContext) Continue() antlr.TerminalNode {
	return s.GetToken(ABSLParserContinue, 0)
}

func (s *KeywordContext) For() antlr.TerminalNode {
	return s.GetToken(ABSLParserFor, 0)
}

func (s *KeywordContext) Switch() antlr.TerminalNode {
	return s.GetToken(ABSLParserSwitch, 0)
}

func (s *KeywordContext) While() antlr.TerminalNode {
	return s.GetToken(ABSLParserWhile, 0)
}

func (s *KeywordContext) Debugger() antlr.TerminalNode {
	return s.GetToken(ABSLParserDebugger, 0)
}

func (s *KeywordContext) Function() antlr.TerminalNode {
	return s.GetToken(ABSLParserFunction, 0)
}

func (s *KeywordContext) This() antlr.TerminalNode {
	return s.GetToken(ABSLParserThis, 0)
}

func (s *KeywordContext) With() antlr.TerminalNode {
	return s.GetToken(ABSLParserWith, 0)
}

func (s *KeywordContext) Default() antlr.TerminalNode {
	return s.GetToken(ABSLParserDefault, 0)
}

func (s *KeywordContext) If() antlr.TerminalNode {
	return s.GetToken(ABSLParserIf, 0)
}

func (s *KeywordContext) Throw() antlr.TerminalNode {
	return s.GetToken(ABSLParserThrow, 0)
}

func (s *KeywordContext) Delete() antlr.TerminalNode {
	return s.GetToken(ABSLParserDelete, 0)
}

func (s *KeywordContext) In() antlr.TerminalNode {
	return s.GetToken(ABSLParserIn, 0)
}

func (s *KeywordContext) Try() antlr.TerminalNode {
	return s.GetToken(ABSLParserTry, 0)
}

func (s *KeywordContext) Class() antlr.TerminalNode {
	return s.GetToken(ABSLParserClass, 0)
}

func (s *KeywordContext) Enum() antlr.TerminalNode {
	return s.GetToken(ABSLParserEnum, 0)
}

func (s *KeywordContext) Extends() antlr.TerminalNode {
	return s.GetToken(ABSLParserExtends, 0)
}

func (s *KeywordContext) Super() antlr.TerminalNode {
	return s.GetToken(ABSLParserSuper, 0)
}

func (s *KeywordContext) Const() antlr.TerminalNode {
	return s.GetToken(ABSLParserConst, 0)
}

func (s *KeywordContext) Export() antlr.TerminalNode {
	return s.GetToken(ABSLParserExport, 0)
}

func (s *KeywordContext) Import() antlr.TerminalNode {
	return s.GetToken(ABSLParserImport, 0)
}

func (s *KeywordContext) Implements() antlr.TerminalNode {
	return s.GetToken(ABSLParserImplements, 0)
}

func (s *KeywordContext) Let() antlr.TerminalNode {
	return s.GetToken(ABSLParserLet, 0)
}

func (s *KeywordContext) Private() antlr.TerminalNode {
	return s.GetToken(ABSLParserPrivate, 0)
}

func (s *KeywordContext) Public() antlr.TerminalNode {
	return s.GetToken(ABSLParserPublic, 0)
}

func (s *KeywordContext) Interface() antlr.TerminalNode {
	return s.GetToken(ABSLParserInterface, 0)
}

func (s *KeywordContext) Package() antlr.TerminalNode {
	return s.GetToken(ABSLParserPackage, 0)
}

func (s *KeywordContext) Protected() antlr.TerminalNode {
	return s.GetToken(ABSLParserProtected, 0)
}

func (s *KeywordContext) Static() antlr.TerminalNode {
	return s.GetToken(ABSLParserStatic, 0)
}

func (s *KeywordContext) Yield() antlr.TerminalNode {
	return s.GetToken(ABSLParserYield, 0)
}

func (s *KeywordContext) Async() antlr.TerminalNode {
	return s.GetToken(ABSLParserAsync, 0)
}

func (s *KeywordContext) Await() antlr.TerminalNode {
	return s.GetToken(ABSLParserAwait, 0)
}

func (s *KeywordContext) From() antlr.TerminalNode {
	return s.GetToken(ABSLParserFrom, 0)
}

func (s *KeywordContext) As() antlr.TerminalNode {
	return s.GetToken(ABSLParserAs, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ABSLParserRULE_keyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(ABSLParserBreak-70))|(1<<(ABSLParserDo-70))|(1<<(ABSLParserInstanceof-70))|(1<<(ABSLParserTypeof-70))|(1<<(ABSLParserCase-70))|(1<<(ABSLParserElse-70))|(1<<(ABSLParserNew-70))|(1<<(ABSLParserVar-70))|(1<<(ABSLParserCatch-70))|(1<<(ABSLParserFinally-70))|(1<<(ABSLParserReturn-70))|(1<<(ABSLParserVoid-70))|(1<<(ABSLParserContinue-70))|(1<<(ABSLParserFor-70))|(1<<(ABSLParserSwitch-70))|(1<<(ABSLParserWhile-70))|(1<<(ABSLParserDebugger-70))|(1<<(ABSLParserFunction-70))|(1<<(ABSLParserThis-70))|(1<<(ABSLParserWith-70))|(1<<(ABSLParserDefault-70))|(1<<(ABSLParserIf-70))|(1<<(ABSLParserThrow-70))|(1<<(ABSLParserDelete-70))|(1<<(ABSLParserIn-70))|(1<<(ABSLParserTry-70))|(1<<(ABSLParserAs-70))|(1<<(ABSLParserFrom-70)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(ABSLParserClass-102))|(1<<(ABSLParserEnum-102))|(1<<(ABSLParserExtends-102))|(1<<(ABSLParserSuper-102))|(1<<(ABSLParserConst-102))|(1<<(ABSLParserExport-102))|(1<<(ABSLParserImport-102))|(1<<(ABSLParserAsync-102))|(1<<(ABSLParserAwait-102))|(1<<(ABSLParserImplements-102))|(1<<(ABSLParserLet-102))|(1<<(ABSLParserPrivate-102))|(1<<(ABSLParserPublic-102))|(1<<(ABSLParserInterface-102))|(1<<(ABSLParserPackage-102))|(1<<(ABSLParserProtected-102))|(1<<(ABSLParserStatic-102))|(1<<(ABSLParserYield-102)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_getter
	return p
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *GetterContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (s *GetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ABSLParserRULE_getter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		p.Match(ABSLParserIdentifier)
	}
	{
		p.SetState(985)
		p.PropertyName()
	}

	return localctx
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_setter
	return p
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(ABSLParserIdentifier, 0)
}

func (s *SetterContext) PropertyName() IPropertyNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (s *SetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitSetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ABSLParserRULE_setter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(987)
		p.Match(ABSLParserIdentifier)
	}
	{
		p.SetState(988)
		p.PropertyName()
	}

	return localctx
}

// IEosContext is an interface to support dynamic dispatch.
type IEosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEosContext differentiates from other interfaces.
	IsEosContext()
}

type EosContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEosContext() *EosContext {
	var p = new(EosContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ABSLParserRULE_eos
	return p
}

func (*EosContext) IsEosContext() {}

func NewEosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EosContext {
	var p = new(EosContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ABSLParserRULE_eos

	return p
}

func (s *EosContext) GetParser() antlr.Parser { return s.parser }

func (s *EosContext) SemiColon() antlr.TerminalNode {
	return s.GetToken(ABSLParserSemiColon, 0)
}

func (s *EosContext) EOF() antlr.TerminalNode {
	return s.GetToken(ABSLParserEOF, 0)
}

func (s *EosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.EnterEos(s)
	}
}

func (s *EosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ABSLParserListener); ok {
		listenerT.ExitEos(s)
	}
}

func (s *EosContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ABSLParserVisitor:
		return t.VisitEos(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ABSLParser) Eos() (localctx IEosContext) {
	localctx = NewEosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ABSLParserRULE_eos)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(990)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ABSLParserEOF || _la == ABSLParserSemiColon) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *ABSLParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 59:
		var t *SingleExpressionContext = nil
		if localctx != nil {
			t = localctx.(*SingleExpressionContext)
		}
		return p.SingleExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ABSLParser) SingleExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 27)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 26)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 25)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 24)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 44)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 43)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 42)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 39)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 38)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
